.. SimpleUI documentation master file, created by
   sphinx-quickstart on Sat May 16 14:23:51 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Работа с оборудованием
================================

Работа со сканерами штрихкода через стандартные настройки. 
-----------------------------------------------------------------

Работа со сканерами ТСД 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Подключение через подписку на событие (рекомендовано)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Производители ТСД поставляют на своих устройствах ПО, работающее как сервис, которое раздает сообщения(intent) при сканировании штрихкода. В настройках ТСД это может называться Intent broadcast или что то подобное со словом “Intent”. Для того, чтобы SimpleUI мог принимать такие сообщения в настройках следует активировать «Использовать подписку на события сканера», заполнить поля «Сообщение сканера», «Переменная сканера» и, в некоторых случаях, «Длина значения»(для случаев когда штрихкод передается не в виде строки а в виде байт-массива и отдельно передается длина значения. Эту информацию можно почерпнуть как правила из документации или примеров.
Этот способ подключения является рекомендованным, т.к. в отличии от различных подключений через эмуляцию клавиатуры этот способ не перехватывает поля ввода на экране.

Подключение через различные виды эмуляции клавиатуры
""""""""""""""""""""""""""""""""""""""""""""""""""""""""

По умолчанию, если сканер настроен выдавать свой результат через эмуляцию клавиатуры и если в конце штрихкода имеется один из вариантов суффикса разделителя строк (например CR, CR/LF ) то подобный ввод воспринимается как штрихкод – т.е. будет сгенерировано событие штрихкода. В случае настроек вывода штрихкода именно как генерации нажатия клавиш друг за другом (обычно в настройках это называется со словом wedge) следует включить галочку Wedge as keys. 

Работа с внешними сканерами штрихкода Bluetooth через настройки 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Можно подключать Bluetooth- сканеры в режиме прямого сопряжения (не через эмуляцию клавиатуры, а через чтение событий сканера напрямую). Это более эффективный путь чем через различные виды эмуляции клавиатуры.

Для подобного сопряжения нужно в настройках поставить галочку “Иcпользовать Bluetooth”, выбрать в выпадающем списке Bluetooth устройство и указать суффикс штрихкода (13 по умолчанию)

.. note::  Этот кейс также можно реализовать собственными силами через методы описанные в разделе «Работа с Bluetooth устройствами». 

Подключение к внешним устройствам через Bluetooth, Wi-Fi и USB. Для всех типов устройств.
---------------------------------------------------------------------------------------------

Работа с Bluetooth устройствами
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В общем случае, для различных категорий Bluetooth устройств схема работы состоит из:

1. Чтение подключенных устройств с целью выбора устройства. Необязательный шаг, если вам известен mac-адрес устройства. На данном шаге могут анализироваться как уже сопряженные устройства так и обнаружение новых
2. Отправка данных на порт устройства – в виде байт-массива. 
3. Подписка на данные, получаемые из устройства

Команды для работы с Bluetooth доступны через импорт java-модуля SimpleBluetooth из python-обработчиков и частично через команды-переменные.

Методы и команды доступные из процессов для выбора устройств:

**BTGetBounded** – команда-переменная для поиска сопряжённых устройств. Получает ответ в переменной **BTResult** в виде JSON-массива подключенных устройств.

**BTStartScan** – команда-переменная для запуска сканирования новых устройств (помимо уже сопряжённых). По окончанию, возвращает результат в **BTDiscoverResult** в виде JSON-массива устройств. Также совместно с этой командой имеет смысл использовать  команду **BTDiscoverHandlers** в качестве параметра к которой указывается стандартный массив обработчиков. Это событие будет сгенерировано по окончанию поиска устройств.

Подключение к устройству в режиме аксессуара (пассивный режим устройства, например принтер)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Подключение к устройству (mac-выбранный из списка устройств mac-адрес устройства,handlers – строка с обработчиками в случае неудачи)

.. code-block:: Python

  from ru.travelfood.simple_ui import SimpleBluetooth as BT

  bt = BT()
  device = bt.get_device(mac) #получение устройства по mac-адресу
  if device==None:
     hashMap.put("toast","Не получилось подключиться")
  else:
     if bt.connect_to_client(device,handlers): #подключение к устройству
                #действия с устройством                                
                bt.close_socket() #отключение от устройства


Подключение к устройству в режиме хоста (активный режим, например сканер)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. code-block:: Python

  from ru.travelfood.simple_ui import SimpleBluetooth as BT

  bt = BT()
  device = bt.get_device(mac)
        if device==None:
            hashMap.put("toast","Не получилось подключиться")
        else:
            if bt.connect_to_server(device):
		#действия с устройством

Отправка данных (методы модуля SimpleBluetooth)
""""""""""""""""""""""""""""""""""""""""""""""""""""

**write_data(<данные>,<строка-массив обработчиков>)** Данные – данные в виде строки, целого числа или массива байтов. Массив обработчиков – строка с обработчиками в случае неудачи

Подписка на данные устройства, отключение подписки (методы модуля SimpleBluetooth)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

**begin_listen_for_data(<строка-массив обработчиков>)** – подключает массив обработчиков на события устройства. Обработчики должны быть обязательно pythonbytes

**stop_listen()** – отключение подписки на события устройства

Подключение к устройству через TCP/IP (только отправка)
-----------------------------------------------------------

Возможно только из python-обработчика. Работа заключается в вызове Java-функции boolean write_socket(String host,int port, String message,String charset) из модуля SimpleUtilites:

.. code-block:: Python

  from ru.travelfood.simple_ui import SimpleUtilites as su
  su.write_socket(IP,port,data,handlers)

, где IP,port – IP-адрес и порт (9100 по умолчанию) принтера

data – либо байт-массив либо строка(UTF-8) данных

handlers – строка-массив обработчиков в случае неудачи

Функция возвращает Истина в случае успешной отправки и Ложь – во всех остальных случаях

Подключение к устройству через USB (только отправка)
-------------------------------------------------------

Подключение осуществляется из модуля SimpleUSB. Сканируются подключенные в такущий момент устройства и возвращается первое из списка либо первый принтер из списка подключенных. 

Подключение и отправка данных на любое устройство осуществляется командой **write_usb(data,handlers)** (data – строка или массив байтов, handlers – обработчики в случае неудачи):

.. code-block:: Python

  from ru.travelfood.simple_ui import SimpleUSB as usbClass  

  usb = usbClass()
  usb.write_usb(data, handlers)

Подключение к принтеру через USB осуществляется аналогичной командой **print_usb(data,handlers)**

.. code-block:: Python

  from ru.travelfood.simple_ui import SimpleUSB as usbClass  

  usb = usbClass()
  usb.print_usb(data, handlers)


Работа с POS-принтерами
-----------------------------

Работа по выводу информации на принтер состоит из двух шагов:

В случае работы напрямую с портом принтера:

1. Подготовка макета для печати – это может быть строка ZPL, ESC-POS, CPCL или другие данные
2. Подключение к принтеру (в случае с Bluetooth – сканирование и выбор принтера,USB – выбор первого из списка подключенных устройств) и отправка на порт принтера данных для печати в виде byte – массива.  Далее при необходимости закрытие сокета.

В случае работы с макетами и печати через менеджер печати Android (опционально -вывод в PNG-файл):

1. Подготовка html-макета документа и вызов команды  PrintPreview
2. *Опционально*. В случае вывода в PNG – этот этап может быть продолжен – картинка встроена в данные, передаваемые на порт принтера, например в zpl  и далее процесс продолжится как в случае подключения напрямую к порту принтера

В случае работы напрямую с портом(сокетом) принтера используются ранее описанные приемы подключения через Bluetooth(как к аксессуару), к TCP-сокету и к USB-устройству (функция print_usb). Данные могут быть представлены строкой или байт-массивом. Далее описаны методы подготовки этого макета.

Подготовка данных для принтера оффлайн используя макеты
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В целом, любые печатные формы (документов, счетов, этикеток) можно оффлайн готовить в виде html-макетов и заполнять шаблонизатором в python. В дальнейшем печать осуществляется через менеджер печати Android.

Данный способ с демо примером описан в статье `<https://infostart.ru/1c/articles/1716745/>`_

Вывод данных макета в png
""""""""""""""""""""""""""""

В дополнению к подготовке макета в виде html, также можно сохранить этот html-документ в виде png-файла с целью дальнейшего вывода на печать не через менеджер печати. Это делается с помощью команды-переменной PrintToBitmap совместно с PrintPreview. Эта команда переопределяет кнопку печати (которая по умолчанию вызывает менеджер печати) таким образом, что происходит сохранение картинки в файл (она помещается в PrintBitmapPath) и вызывается обработчик события с listener=PrintBitmap . Т.е. перехватив данный обработчик можно получить картинку из файла и продолжить с ней работу.

Работа с готовым PDF либо подготовка онлайн
""""""""""""""""""""""""""""""""""""""""""""""

В случае, если необходимо напечатать или вывести на предпросмотр PDF файл можно воспользоваться командами-переменными PrintPDF и ViewPDF передав в качестве параметра путь к PDF-файлу.
Также можно подготовить PDF на стороне веб сервиса, описано тут `<https://uitxt.readthedocs.io/ru/latest/common_functions.html?highlight=pdf#id28>`_

Подготовка данных для принтера с использованием языков ZPL,ESC POS и т.д.
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Принтер ожидает байт-массив котрый может быть закодированной строкой, которая из себя может представлять как просто текст, так и макет страницы или управляющие комманды, в специальном языке разметки.
Для разметки страницы могут использоваться любые языки разметки. Можно готовить подобные разметки вне приложения (например использовать онлайн-конструктор разметки, после чего менять в нем значения полей заменой в тексте). Можно генерировать код самими в коде обработчика. Также существует ряд библиотек котрые генерируют разметку по исходным данным в удобной для разработчика форме. В пакет приложения включены библиотеки zpl (`<https://pypi.org/project/zpl/>`_) и escpos-gen (`<https://pypi.org/project/escposgen/>`_)

Расширенное взаимодействие с SDK некоторых устройств
---------------------------------------------------------

Для устройств некоторых производителей в SimpleUI интегрирована поддержка Android-SDK этих производителей, которая дает дополнительные функции. Например, для ТСД это может быть, помимо просто сканирования штрихкода, возможность включать и выключать сканер программно, блокировать сканер, получать дополнительную информацию в приложении. Не все производители реализуют подобный SDK

ТСД Urovo
~~~~~~~~~~~~~~

Функции для Urovo реализованы в модуле SimpleUtilites (from ru.travelfood.simple_ui import SimpleUtilites)

**urovo_set_lock_trigger(<статус>)** блокировка/разблокировка сканера(если заблокирован, то заблокирована кнопка сканирования). Статус – истина(заблокировано), ложь (разблокировано)

** urovo_open_scanner()** - открыть объект сканера (не запускает сканирование, а просто инициализирует сканер и проверяет доступность) . Эта функция должна предшествовать urovo_start_decode

**urovo_start_decode()** включает сканер в режим сканирования

**urovo_stop_decode()** выключает режим сканирования

**urovo_close_scanner()** завершает работу со сканером

**urovo_get_scanner_state()** возвращает текущее состояние сканера

**urovo_get_lock_trigger_state()** возвращает текущее состояние блокировки сканера

ТСД Meferi
~~~~~~~~~~~~~~

ТСД Meferi имеет свое Андроид-SDK которое позволяет упраять состоянием сканера и настройками ТСД в целом. В SimpleUI включен сам SDK и он отдается разработчику в виде объектов класса

.. code-block:: Python

  from ru.travelfood.simple_ui import Meferi as Meferi
  
  #получение объекта класса ScanManager
  manager = Meferi().getScanManager()
  #далее работа с объектом, утилизация методов
  manager.setScanEnable(True)
  manager.keyScan(True)



