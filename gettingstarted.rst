.. SimpleUI documentation master file, created by
   sphinx-quickstart on Sat May 16 14:23:51 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Быстрый старт
=================

Примеры, указанные в этой статье содержатся в комплекте разработчика в файлах Sample1_gettingStarted.txt (конфигурация SimpleUI), файлах обработчиков handlers_sample1.py,sample1_global_module.py и файле-имитации онлайн сервиса back_service_sample.py 

Пример 1. Развертывание системы, разметка экрана и обработчики на Python.
---------------------------------------------------------------------------------

*Создадим новый проект, проверим что он запускается на устройстве и создадим процесс, состоящий из одного экрана, на котором будут вводиться 2 числа и вычисляться результат их сложения по кнопке.*

Развертывание
~~~~~~~~~~~~~~~~~

.. image:: _static/new_project.png
       :scale: 100%
       :align: center

Запускаем конструктор simple_editor.exe, выбираем Файл-Новый проект… после чего создается примитивная конфигурация, состоящая из одного процесса и экрана. Это уже можно посмотреть на устройстве и самое время проверить связь с устройством. В конструкторе используется Flask который транслирует файл конфигурации по запросу устройства в сети, это удобно на этапе разработки, чтобы не передавать файл вручную

.. note:: Внимание! Передавать файл конфигурации через веб-сервис не обязательно, это можно сделать любым способом через файл, отправив его, например по почте. Но это удобно на этапе разработки чтобы быстро доставлять изменения, поэтому конструктор содержит flask сервер.

Нам нужно передать настройки подключения к сервису конструктора на устройстве. Это можно сделать через QR-код, который генерирует конструктор – Файл- QR-настройки. Запустите Simple UI на устройстве и выберите в меню QR-настройки, сканируйте код и перезапустите приложение (либо нажать в главном меню Обновить приложение). На устройстве должно появиться меню конфигурации – развертывание прошло успешно.

.. image:: _static/qr.png
       :scale: 100%
       :align: center

Cобственно, разработка...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Переименуем имя процесс и имя экрана на что то осмысленное. Можно еще поставить «Скрывать нижние кнопки» так как они не нужны. В экране, в Структуре добавим новый элемент «Контейнер», поставим ориентацию -вертикально и Длину и Ширину – на весь контейнер. Это будет корневой контейнер экрана.

Добавим несколько элементов – надписи, поле ввода и кнопку. У всех ставим ширину – на весь контейнер. У надписей мы определяем Значение, у полей ввода – переменные, в котрые будут попадать введенные значения. У кнопки в Значение пишем надпись кнопки, а в переменную - некую переменную, по которой обработчик будет понимать что нажата именно эта кнопка.

.. image:: _static/task1_layout.png
       :scale: 80%
       :align: center

.. note:: Можно создавать разметку любой сложности вписывая в контейнер другие контейнеры – горизонтальные и вертикальные любой сложности.

Теперь можно перезапустить конфигурацию на устройстве и посмотреть что получилось.

Теперь нужно сделать чтобы работала кнопка. Для этого нужны обработчики либо онлайн(на стороне вашей учетной системы) либо оффлайн. В рамках этого примера мы сделаем оффлайн обработчик на Python. Для этого нужно открыть любую IDE Python и сделать так какой то файл где будут содержаться все обработчики проекта, например hanlers.py и указать путь к нему на странице обработчики. Каждый обработчик должен иметь определенную структуры вызовов , например:


.. code-block:: Python

  def sample1_on_create(hashMap,_files=None,_data=None):
    
    return hashMap

Все переменные, события, команды  передаются через стек hashMap и возвращаются через него же. Помещать в hashMap нужно функцией put(key,value), читать функцией get(key), проверять существование функцией containsKey(key) а удалять remove(key)

.. attention:: Все переменные в этом стеке строго строковые! Нельзя помещать например число.

Переменные a и b, которые связаны с полями ввода помещаются в стек переменных автоматически. Вывести результат можно на экран в виде Надпись, но для простоты мы выведем в тост командой toast. Все команды также помещаются в стек переменных - hashMap.put("toast",”Hello wolrld”)

Все события помещаются в переменную listener, соответвенно при нажатии кнопки будет сгенерировано событие равное переменной этой кнопки как мы задали ее в структуре экрана.

Обладая этими знаниями заведем новую функцию которая будет обрабатывать события ввода этом экране:



.. code-block:: Python

  def sample1_on_input(hashMap,_files=None,_data=None):
    if hashMap.get("listener")=="btn_res":
        hashMap.put("toast",str(int(hashMap.get("a"))+int(hashMap.get("b"))))    
    
    return hashMap

Необходимо связать файл обработчиков с конфигурацией, указав файл на закладке "Обработчики"

.. image:: _static/handlers_task1.PNG
       :scale: 100%
       :align: center

Важно понимать, что после нажатия кнопки будет сгенерировано событие ввода и потом экран будет перерисован и то что введено в полях ввода пропадет, что не очень хорошо. Поэтому нужно зайти вс структуры экрана и добавить в Значения в полях ввода переменные a и b через @. Значение – это значения по умолчанию для полей ввода, а символ «@» в SimpleUI означает привязку переменных к элементам. С помощью него можно выводить например надпись на экран. 

Например, можно вывести результат не через тост а через Надпись, указав в значении @result , тогда в обработчике над будет заполнить переменную result

.. code-block:: Python

  hashMap.put("result",str(int(hashMap.get("a"))+int(hashMap.get("b"))))    

Но, при первом запуске экрана, до нажатия кнопок , переменные a и b – пусты и это не очень красиво будет смотреться на экране, поэтому нужен еще один обработчик, который их заполнит:

.. code-block:: Python

  def sample1_on_create(hashMap,_files=None,_data=None):
    if not hashMap.containsKey("a"):
        hashMap.put("a","")    
    if not hashMap.containsKey("b"):
        hashMap.put("b","")        
    return hashMap

Обратите внимание обработчик заполняет пустую строку в a и b только тогда, когда они отсутствуют в стеке переменных

Все, теперь осталось только указать эти обработчики в конструкторе на закладке Обработчики, перезапустить конфигурацию и проверить как это работает.

.. image:: _static/handlers_task1.PNG
       :scale: 100%
       :align: center

 


Пример 2. Работа с сканером, несколькими экранами, SQL через ORM и напрямую и онлайн и оффлайн обработчиками.
-----------------------------------------------------------------------------------------------------------------------




*Этот процесс будет содержать два экрана. На первом происходит сканирование штрихкода. На нем же отображаются ранее отсканированные записи, в виде таблицы. На втором экране будет происходить ввод количества и добавление записей в SQL СУБД приложения.* 


.. image:: _static/task2_result.PNG
       :scale: 40%
       :align: center


Добавляем процесс, переименовываем первый экран в «Сканирование штрихкода». Он будет просто содержать надпись-подсказку и таблицу. Таблицу можно пока не добавлять, добавить после того как закончим второй экран. Надпись имеет смысл оформить более ярко, чтобы она выделялась на экране.

Также на этом экране размещаем элемент Штрихкод который будет сканировать в переменную barcode.

.. image:: _static/add_barcode.PNG
       :scale: 42%
       :align: center

Если это устройство – терминал сбора данных или подключен сканер штрих кодов, то сканирование будет происходить на аппаратном уровне в соответствии с настройками, если такого сканера нет то камерой устройства при нажатии на кнопку сканирования внизу справа. 

Обязательно указывать переменную в которую будет сканироваться штрихкод, иначе управляющий элемент просто не будет размещен на экране.

Этого достаточно, теперь нужно написать обработчик ввода. Обработчик будет выполняться онлайн – в учетной системе. Это может например ваша WMS-система, из которой опубликован веб-сервис, который будет принимать команды обработчиков. Но так, как неизвестно какая система используется у вас и ее невозможно включить в комплект разработчика, пример будет написан также на Python и Flask, важно показать принцип построения http-сервиса, чтобы вы могли воспроизвести его в своей учетной системе.

Пример сервиса находится в комплекте разработчика back_service_sample.py

Структурно, ваш сервис должен принять и обработать запрос /set_input_direct/<method>

Где method – имя вызываемой функции, на стороне учётной системы и должен содержать эту функцию. Так, в примере он содержит одну функцию barcode_on_input()  и соотвественно платформа при наступлении события ввода шлет ему запрос /set_input_direct/ barcode_on_input

Пропишем ее в обработчике Онлайн , При Открытии экрана:

.. image:: _static/barcode_on_input.PNG
       :scale: 100%
       :align: center


Все переменные которые есть на этот момент также как и с обработчиком на python заходят в виде стека и выходят в виде стека, толкьо в данном случае это происходит в виде секции hashmap в json запросе. Для работы со стеком переменных тут сделан класс hashMap, который работает также как и на python

Еще в json ответа есть переменная ErrorMessage которую также можно заполнить в случае ошибки – она отобразит какую то ошибку на экране. Остальные поля добавлены для совместимости со старыми версиями и не используются сейчас.

Сам обработчик barcode_on_input ловит событие сканирования, читает штрихкод и ищет по массиву товаров goods_sample нужный штрихкод (конечно в реальной системе он будет искать в базе данных, но тут это сделано для примера).

Результат он записывает в переменную nom.

Также, поскольку у нас есть второй экран, его нужно показать после того как штрихкод будет обработан и товар определен. Делается это командой ShowScreen где в качестве аргумента используется имя экрана. Можно например не переключать экран если товар не найден (а в примере он переключается в люом случае по сканированию). Т.е. пока команды не будет – экран не переключится сам.

Структуру второго экрана можно посмотреть в примере. 

.. attention:: Сервис, который будет обрабатывать обработчики онлайн (back_service_sample.py) необходимо запустить, чтобы он работал, после чего нужно в настройках приложения происать в Параметры доступа к обработчикам WebService URL вида http://<IP-адрес сервиса>:2075 (если сервис запускается на том же компьютере что и конструктор то IP-адрес будет тот же, другой порт)

.. image:: _static/sui_settings.PNG
       :scale: 55%
       :align: center

Второй экран содержит логику работы с СУБД. В приложении есть стандартная SQLite на устройстве и с ней можно работать из обработчиков python либо с помощью sqlite3 api (этот способ я называю «напрямую» либо с помощью ORM Pony которая описана в документации и также имеет собственную документацию. 

Можно совмещать оба этих способа. 

Для начала нам нужно создать таблицу в СУБД в которой будут храниться добавляемые штрихкоды и количество. Ее, кстати можно создать, поместив CREATE TABLE IF NOT EXIST …  на закладку SQL при запуске. Но мы создадим через ORM, так удобнее. Для работы с таблицами СУБД сделаем дополнительный общий модуль ui_global , пример в комплекте разработчика в sample1_global_module.py в котором определяется подключение к СУБД, создаются таблицы и происходит инициализация generate_mapping (все это относится к Pony ORM и я не буду тут подробно останавливаться на этом). Важно то, что мы создали объект Record который также является таблицей Record

.. code-block:: Python

 class Record(db.Entity):
        barcode =  Required(str)
        name =  Required(str)
        qty = Required(int)

Нам надо указать его на закладке Дополнительный Python – модули.

.. image:: _static/additional_modules.png
       :scale: 100%
       :align: center

Теперь мы можем использовать его в import и вызывать в обработчиках. Добавим в импорт и создадим обработчик

.. code-block:: Python

 import ui_global
 
 def init_on_start(hashMap,_files=None,_data=None):
    ui_global.init()
    return hashMap

Теперь нам надо чтобы init_on_start вызывалась при запуске системы, укажем вызов на закладке "Обработчики таймеров/при запуске", указав в качестве периода -1 (положительные значения это интервал таймера в миллисекундах, а -1 означает однократное выполнение)

.. image:: _static/on_start.png
       :scale: 100%
       :align: center

На этом этапе у нас по идее при запуске приложения должна создаться таблица Record 

Проверим это - перезапустим приложение. Мы можем зайти в консоль SQL-запросов в Файл-Консоль SQL и выполнить например Select * from Record или выполнив запрос 


.. code-block:: SQL

 SELECT name FROM sqlite_master WHERE type='table'
 
который выводит список всех таблиц в СУБД – среди них должна быть Record

Дальше все просто. Нам нужно написать обработчик на Python который будет записывать введенные ранее переменные barcode, nom (из онлайн обработчика) и qty в таблицу

Это делается очень просто :

.. code-block:: Python

 def input_qty(hashMap,_files=None,_data=None):
    with db_session:
        p = ui_global.Record(barcode=hashMap.get('barcode'),name=hashMap.get('nom'), qty=int(hashMap.get('qty')))
        commit()

    hashMap.put("ShowScreen","Сканирование штрихкода")
    hashMap.put("toast","Добавлено")
    return hashMap

Предполагается что сделаны импорты:

.. code-block:: Python

 import ui_global
 from pony.orm.core import db_session
 from pony import orm
 from pony.orm import Database,Required,Set,select,commit

Обработчик, как видно помимо добавления записи, также выводит тост и переключает на предыдущий экран, замыкая цикл.

Остается толкьо прописать обработчики на закладке Обработчики и проверить работу.

У нас остался еще один обработчик, который будет выводить таблицу Record на форме (кстати после того как вы добавите хотя бы один товар можно снова зайти в SQL-консоль и еще раз попробовать сделать Select * from Record – там будут записи)

Для этого мы размещаем на первом экране таблицу и пишем обработчик on_start_barcode который прочитает записи в Record. Переменная таблицы (как и других сложных экранных форм) – это JSON объект, описывающий структуру и данные. Это лучше брать из справки и адаптировать под себя. В нашем случае мы добавляем таблицу с тремя столбцами (штрихкод, наименование  и количество) – массив columns и добавляем в rows записи из базы данных.

.. code-block:: Python

 table  = {
    "type": "table",
    "textsize": "20",

    "columns": [
    {
        "name": "barcode",
        "header": "Barcode",
        "weight": "2"
    },
    {
        "name": "name",
        "header": "Name",
        "weight": "2"
    },
      {
        "name": "qty",
        "header": "Qty.",
        "weight": "1"
    }
    ]
    }
    
    #work with SQL via Pony ORM
    query = select(c for c in ui_global.Record)
    rows=[]
    for record in query:
        rows.append({"barcode":record.barcode,"name":record.name,"qty":record.qty})

    table['rows'] =rows   
    hashMap.put("table",json.dumps(table))

    return hashMap


Пример 3. Показ остатков товара в Active CV (дополненной реальности), работа с SQL напрямую
-----------------------------------------------------------------------------------------------------

*Этот пример самый простой, поскольку основное уже сделано в предыдущем пункте. Active CV – читает информацию в видеопотоке, детектирует различными детекторами (шрихкод, OCR и т.д.) и накладывает ее на видеоток в реальном времени. Можно было бы сделать показ остатков через экраны – сканировать товар, запрашивать остаток в таблице и показывать на экране. Но с Active CV этот процесс бесшовный – можно обрабатывать различные процессы ничего не нажимая на устройстве.*

Для этого создадим процесс Active CV, создадим и заполним один новый шаг


.. image:: _static/active_cv.png
       :scale: 100%
       :align: center

Данное заполнение означает что картинка будет выводиться в 720p, в кадре будут детектироваться штрихкоды и будут показываться объекты только из списков.

По шагу возникают различные события, например, «обнаружен новый объект» , но нас интересует только начальное заполнение данных, которое в ActiveCV происходит через списки и только событие  «При запуске». Списки делятся по цветам (зеленый, красный и т.д.) и есть другие списки, передающие информацию. Простейший пример – «зеленый список» - объекты из него будут подсвечиваться зеленым, например нужные на складе товары, а в красный попадут товары с истекающим сроком годности. Нас для примера интересует только зеленый список  специальная переменная **green_list**

И обработчик будет один  on_start_active_cv В нем мы прочитаем из СУБД эту таблицу и заполним **green_list** и в дополнении заполним еще один регламентированный список - **object_info_list** (в нем будет выведена дополнительная информация по объекту -название и остаток)

.. image:: _static/active_cv_handler.png
       :scale: 75%
       :align: center

При этом можно было бы скопировать обработчик из предыдущего примера на ORM или сделать произвольный запрос на ORM, но в качестве примера приводится работа с базой напрямую.

В итоге в стек переменных попадают 2 переменные – green_list (список штрихкодов с разделителем “;”) и object_info_list – json массив описаний объектов (кстати тут как и везде в Simple UI можно указывать html-строки вместо обычных чтобы выделить внешний вид)

.. code-block:: Python

 def on_start_active_cv(hashMap,_files=None,_data=None):

    import sqlite3 # This is another way to work with SQL
    from sqlite3.dbapi2 import Error
    import json

    
    #create connection with database
    conn= None
    try:
        conn = sqlite3.connect('//data/data/ru.travelfood.simple_ui/databases/SimpleWMS')
    except Error as e:
        raise ValueError('No Database connection!')
  
    cursor = conn.cursor()
    cursor.execute("SELECT barcode,name,qty FROM Record")

    results = cursor.fetchall()

    green_list = []
    red_list= []
    info_list = []
    for link in results:
        job = {"object":str(link[0]),"info":str(link[1])+" </n> Остаток: <big>"+str(link[2])+"</big>"}
        info_list.append(job)
        green_list.append(link[0])    
            
    conn.close()     

    hashMap.put("object_info_list",json.dumps(info_list,ensure_ascii=False))
    hashMap.put("green_list",';'.join(green_list))
    
    return hashMap

После того как списки заполнены, при запуске этого процесса открывается видеопоток в котором при наведении на объект показывается его название и остаток.

.. image:: _static/cv_result.png
       :scale: 42%
       :align: center
