.. SimpleUI documentation master file, created by
   sphinx-quickstart on Sat May 16 14:23:51 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Python в обработчиках
=======================

Приложения Simple UI могут использовать интерпретатор Python для выполнения кода обработчиков  в любом режиме. Можно писать код обработчиков используя процедуры, классы, библиотеки. Перечень библиотек и актуальная версия интерпретатора может меняться от релиза к релизу и информация об этом будет обновляться.

На текущий момент используется:

 *  Версия Python - 3.8


Подключены библиотеки:


 *  Стандартные библиотеки
 *  Requests
 *  Lxml
 *  Pandas
 *  BeautifulSoup
 *  pony
 *  Pillow
 *  Jinja2
 *  python-barcode
 *  pymongo


.. note:: Apk по умолчанию не включает поддержку режима x_86 поэтому не будет выполняться в эмуляторе на ПК. Если нужен такой режим – обращайтесь за отдельной версией (изза большого размера не включается в стандартную поставку)

Обработчики Python для экранов "При запуске" и "Обработка ввода" могут выполняться совместно с обработчиками закладки «Offline&Rest» и обработчиками сервиса онлайн (1С) на экранах в последовательности: 1) Python 2) Offline&REST 3) 1С


Кроме того предусмотрены отдельные общие виды обработчиков: 

 *  При запуске конфигурации
 *  По расписанию - общий обработчик (периодичность задается в настройках). Запускается в сервисе, работает при неактивном приложении.
 *  По настраиваемому расписанию - обработчики на закладке "Произвольные таймеры". Можно добавить любое количество обработчиков по расписанию с периодичностью от 1 мс.
 *  Обработчик ответа в уведомлении
 *  Обработчик фонового сервиса
 *  При получении контента (поделиться, открыть файл) -* пока не документировано, см. демо

Начиная с с версии 7.00 также появился общий модуль (закладка Общий модуль). Можно разместить там свои функции и потом использовать их через import ui_general

Код можно запускать из кода - синхронно (в UI-потоке) и асинхронно (в фоне). Код надо передавать в виде строк Base64:

 *  **RunPy** - запускает синхронное выполнение скрипта Python в UI-потоке приложения. В качестве параметра передается скрипт в виде Base64-строки
 *  **RunPyThread** - запускает асинхронное фоновое выполнение скрипта Python. В качестве параметра передается скрипт в виде Base64-строки

Код обработчиков взаимодействует с данными и интерфейсов Simple UI через:

 *  Переменные (локальные и глобальные переменные, команды в переменных как обычно)
 *  Прямые запросы SQL в СУБД приложения

Все что нужно знать о взаимодействии с переменными, а следовательно и с самим приложением:

 *  Записать в Переменные : hashMap.put(“имя переменной”, значение переменной)
 *  Прочитать из переменных: hashMap.get(“имя переменной”)

Пример кода обработчика на Python:

.. code-block:: Python

  import json
  import requests
  
  r = requests.get('https://www.cbr-xml-daily.ru/daily_json.js')
  jdata = json.loads(r.text)
  rate =jdata.get("Valute").get("BRL").get("Value")
  #Записываем в Переменные
  hashMap.put("rate",rate)


Функции, с произвольным числом аргументов
----------------------------------------------

Можно использовать функции с произвольным числом неименованных аргуметов (обычно называют *args). Для этого надо выбрать в настройке обработчика **pythonargs**

Пример кода такого обработчика:

.. code-block:: Python

  def foo(hashMap,*args):
    param1 =  args[0] 
    param2 =  args[1] 
    param3 =  args[2]  

    return hashMap

Функции платформы, которые работают run-time (модуль android)
-------------------------------------------------------------------

Все функции доступны через команды-переменные, но часто это не совсем удобно. Например, надо вывести тост внутри долгого обработчика или обновлять уведомление внутри цикла, а не после выполнения такта обработчика (а стек-машина выполняет команды-переменные по окончанию такта). Это именно run-time на уровне системы, т.е. выполняется непосредственно в момент вызова. Все подобные функции собраны в модуль вpython- модуль android и их можно использовать так:

.. code-block:: Python

 import android
 android.toast("hello")


Интерфейсные команды:
 
 * **toast(String toast)** – вывести сообщение Андроид 
 * **speak(String text)** – произнести текст (TTS engine)
 * **listen()** – запустить ожидание распознавания речи
 * **vibrate()** и **vibrate(int duration)** – вибрация и вибрация заданной длительности
 * **beep()/beep(int tone)/ beep(int tone,int beep_duration,int beep_volume)** – звуковой сигнал, т.ч. с возможностью выбрать тон (от 1 до 99), продолжительность и громкость (по умолчанию – 100)
notification(String message)/ notification (String message,String title)/ notification(String message,String title,int number) – уведомление в шторке уведомлений. Number – идентификатор уведомления, по которому к нему можно потом обратиться, чтобы либо убрать, либо перезаписать (обновить)
 **notification_progress(String message,String title,int number,int progress)** – уведомление с прогресс-баром (от 0 до 100)
 **notification_cancel(int number)**  – скрыть уведомление

Управляющие команды:

 * **refresh_screen()** запускает рефреш экрана. Предполагается, что стек будет установлен рантайм методами работы со стеком
 * **refresh_screen(hashMap)** - запускает рефреш и передает стек. 
 * **RunEvent(String handlers)** – запустить массив обработчиков
 * **BackgroundCommand(command)** – запустить фоновую команду
 * **stop()** или **stop(hashMap)** – точка останова для отладки

Работа со стеком:

 * **get_process_hashmap()** – получает стек переменных экрана из любого места
 * **get_cv_hashmap()** – получает стек переменных ActiveCV из любого места
 * **get_service_hashmap()** – получает стек переменных фонового сервиса из любого места
 * **process_started()** – получает признак, запущен ли процесс в данный момент
 * **cv_started()** – получает признак, запущено ли ActiveCV в данный момент
 * **put_process_hashMap(key,value)** помещает значение в стек процесса
 * **remove_process_hashMap(key)** – удаляет значение из стека процесса
