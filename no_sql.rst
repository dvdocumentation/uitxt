.. SimpleUI documentation master file, created by
   sphinx-quickstart on Sat May 16 14:23:51 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Режим хранения NoSQL
========================


 
.. warning:: Важно! Параллельно с SQL данные на устройстве теперь можно хранить в NoSQL- СУБД. Этот режим обладает множеством преимуществ, главное из которых - простота разработки. Хранение в NoSQL не исключает хранение в SQL - можно одновременно использовать и то и то.

В NoSQL СУБД данные хранятся в режиме "ключ - значение" а не в таблицах. В любой ключ можно записать любое значение - текст, JSON и т.д. Т.е. работа происходит с неструктурированной информацией. Структуры данных типа документов и справочников удобнее хранить в JSON.

С NoSQL базами можно работать через стек переменных и непосредственно из python– обработчиков. В случае работы через методы класса NoSQL преимуществом является получение результата сразу, также то что просты типы можно использовать как есть, без преобразования в строку.

Работа с NoSQL через методы класса NoSQL из python-обработчиков
------------------------------------------------------------------------

Для работы необходимо подключить класс NoSQL и создать объект. Импортировать класс можно двумя способами:

1-й вариант:

.. code-block:: Python

  from ru.travelfood.simple_ui import NoSQL as noClass
	
2-й вариант:

.. code-block:: Python

  from java import jclass
  
  noClass = jclass("ru.travelfood.simple_ui.NoSQL")

Далее нужно создать объект, указав в качестве параметра имя существующей или новой БД. Она будет создана при необходимости

.. code-block:: Python

  ncl = noClass("test_new_nosql")


Методы объекта:

**put(ключ, значение, регистрировать_в_очереди)** – помещает значение в указанный ключ. Значения типов строка, число, булево – можно помещать как есть. JSON лучше преобразоывать в строку. Пример: ncl.put("k1","Это строка",True)

**get(ключ)** – получает значение по ключу

**delete(ключ)** – удаляет ключ

**destroy()** – уничтожает все ключи базы

**getallkeys()** – получить список всех ключей базы в виде строки формата JSON-массива строк
	
**findJSON(поле,значение)** – медленный поиск среди всех объектов базы которые имеют тип JSON , объектов, в **поле** которых есть **значение**. Возвращает строку с JSON-массивом найденных объектов. Лучше использовать в базах, где мало значений, если значений много -лучше испоьзовтаь поиск с индексом.

Пример:

.. code-block:: Python

  j3 = {"name":"Дарья","surname":"Смирнова"}  
  ncl.put("jk3",json.dumps(j3,ensure_ascii=False),True)  

  #Поиск без индекса
  res = ncl.findJSON("name", "Дарья") 
  jres = json.loads(str(res).encode("utf-8"))   


**run_index(имя_индекса,поле** – создание индекса по JSON-объектам для дальнейшего использования для поиска. Создает, асинхроннно индекс, состоящий из объектов с указанным полем.

**findJSON_index(имя_индекса, поле, значение) ** – поиск по индексу. Возвращает строку с JSON-массивом найденных объектов. Поиск ведется по ключам, в которых записаны JSON-строки объектов.

Работа с NoSQL через стек переменных
-------------------------------------------------------

Вся работа происходит через Переменные (в Python - hashMap). Например в Переменные передается команда к СУБД и данные, которые надо вставить. Данные, запрошенные из СУБД также возвращаются в Переменные.

В конфигурации можно определить название СУБД в поле "Имя базы noSQL" , чтобы у каждой конфигурации была собственная СУБД, а можно не использовать разделение, например чтобы можно было использовать общие данные.


Базовые команды
~~~~~~~~~~~~~~~~~~

1)Запись, чтение, удаление:

 * **(put_ключ, переменная)** - записать данные в СУБД в ключ 
 * **(get_ключ, переменная)** - получить данные из СУБД из ключа в переменную. Если в обработчике есть команды get_, find_ и finindex_ система извлекает данные из СУБД в Переменные, после чего вызывает событие "_results" (как бы новый такт обработчика)
 * **(del_ключ,)** - удалить ключ
 * **(getallkeys, переменная)** -  получить список всех ключей

2)Поиск и индексы:

 * **(find_имяпеременной, имяполя=значение)** - "условно медленный" поиск по объектам в СУБД. в "имяпеременной" возвращается JSON-массив найденных объектов. "имяполя" - имя поля в корне JSON объектов по кторому будет вестись поиск. Вид сравнение можно использовать "="(точное сравнение) или "~"(вхождение подстроки). Значение - значение поиска.
 * **(createindex_имяиндекса, имяполя)** и (findindex_имяиндекса, имяполя=значение). Индексы - загруженные в память таблицы значение - ключ, по которым происходит более быстрый поиск. Т.е. если индекс задать заранее, поиск будет произвдиться очень быстро - ведь это поиск по массивы у памяти а не в СУБД. Поэтому где в начале, возможно при запуске конфигурации, следует создать нужные индексы командой createindex_. Далее использовать команду findindex_, где в качестве параметра поиска уже использовать имя ранее созданного индекса.

3)Очередь

Очередь используется для автоматической фиксации изменённых или добавленных объектов. Это используется например для синхронизации - всегда можно получить список ключей, измененных на устройстве, чтобы выгрузить в основную систему. Очередь пишется автоматически, но ее можно выключить например при загрузке данных из учетной системы командой ("StopQueue","")

 * **_sys_queue** - переменная-очередь, в которой всегда содержится список ключей объектов, разделенных через ";"
 * **(removequeue,ключ)** - удалить ключ из очереди (например, при успешной выгрузке)


Работа с переменными. 
----------------------
Можно просто записать все переменные или список переменных в СУБД, а потом извлечь.

 * **(puthasmap,списокпеременных)** - записать дамп переменных в СУБД, списокпеременных - список имен переменных через ";"
 * **(gethashmap,)** - прочитать дамп переменных из СУБД в Переменные
