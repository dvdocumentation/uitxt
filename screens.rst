.. SimpleUI documentation master file, created by
   sphinx-quickstart on Sat May 16 14:23:51 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Экраны, переменные и события
============================

Переменные, глобальные переменные и константы.
-----------------------------------------------

Стек обычных переменных (структура) существует пока запущен процесс. Поместить переменную можно через структуру Переменные, установив имя и значение переменной. Также существуют специальные переменные (например GPS-координаты), управляющие переменные. Также переменные могут быть установлены через поля экрана или контейнера «Записывать в переменную». К такой переменной можно обратиться из кода и или вывести на экран(либо использовать в других местах, например в оффлайн) употребив префикс “@”. 
Но стек переменных перестает существовать когда процесс закрывается. При повторном открытии структура снова пустая.
Глобальные переменные  позволяют организовать общий стек переменных между процессами. Т.е. переменная может быть записана в одном процессе, а прочитана в другом, либо в том же при повторном открытии. Они существуют пока запущено приложение. 
Работать с ними точно также только название самой переменной должно начинаться с «_», напрмиер “_var1”, “_var2”. Обращаться к ним по тому же имени. При обращении через экран это будет соотвественно “@_var1”, “@_var2”. Т.е. программа, если видит что название переменной начинается с символа подчеркивания – просто помещает их в отдельный стек переменных. Для программиста работа с такими переменными больше ничем не отличается
Константы позволяют записывать значения переменных в памяти устройства. Т.е. если закрыть и открыть приложение константа может быть прочитана снова. Таким образом можно организовать например настройки приложения. Поддерживаются строковые константы через которые можно выразить все остальное. Например в демо базе показана работа с флажком (флажок управляется строками “true” /’false”) и со строковой переменной. Но можно хранить и число. 
Для установки константы нужно написать 2 подряд управлящие переменные ``WriteVarString[номер]`` и ``WriteVarStringValue[номер]`` , где номер – просто какой то номер. Суть в том что если надо вставить несколько констант за раз  то в Структуре они должны храниться отдельно, а если вставить несколько раз одинаковую переменную то останется только последнее значение. Поэтому надо написать что то типа

``Переменные.Вставить("WriteVarString1","string_var1");``
``Переменные.Вставить("WriteVarStringValue1",Переменные.string_var1);``

``Переменные.Вставить("WriteVarString2","cb");``
``Переменные.Вставить("WriteVarStringValue2",Переменные.cb);``

Тут видно что в первых двух строчках устанавливается первая константа, в следующих двух – вторая. Константы записываются в хранилище устройства как “string_var1” и ‘cb’

Для чтения констант используется ``ReadVarString[номер]``
Например ранее установленные константы:

``Переменные.Вставить("ReadVarString1","string_var1");
Переменные.Вставить("ReadVarString2","cb");``

Константы хранятся в том же хранилище что и константы приложения. Поэтому не следует называть их также как названы строковые константы приложения: “URL”, “User”, “Pass”, “Code”

Переключение экранов 
------------------------------------

У каждого экрана  необходимо прописать действия для переключения или вызова других экранов. Иначе экран просто будет оставаться несменяемым. Даже если не отключена стандартная панель кнопок.
Переключение может происходить через стандартную панель и также можно сделтаь свои кнопки и определить обработчики в них. Либо переключения могут происходить по каким то событиям – чтение штрихкода, таймер и т.д. Собственно говоря как такового «переключения» может не быть – многие приложения состоят из одного экрана, а остальные экраны вызываются по необходимости
Порядок переключения может быть определен через обработчики кнопок или стандартных элементов с помощью команды «ShowScreen». Например 

``Переменные.Вставить("ShowScreen","Экран 2 стандартные кнопки");``

В обработчиках Python соотвественно надо вставить:

``hashMap.put("ShowScreen","Экран 2 стандартные кнопки");``

Также как альтернатива определить **обработчики в разделе OFF-Line & REST**. Это подойдет как для самостоятельных приложений так и просто для удобства (если например не надо писать условия для переключения экранов, а нужно сделать это безусловно)

.. image:: _static/command_showscreen.jpg
       :scale: 50%
       :align: center



Обработка событий для он-лайн(1C) и Python-обработчиков
---------------------------------------------------------

Кнопки контейнеров, диалоги ввода, штрихкоды и другие управляющие элементы передают события которые можно использовать в алгоритмах. Как только происходит событие происходит запрос ввода либо обработка оффлайн события

В Переменные пишутся 2 переменные

 * event
 * listener

в *event* пишется тип события: Input (люой ввод – кнопки, штрихкоды и т.д.), onResult(экран диалога) и onStart(запуск экрана)
в *listener* пишется расшифровка- либо переменная (кнопка) либо зарезервированное название операции barcode, signature, photo

Допустим на экране размещен элемент экрана «Штрихкод» и указано «Записывать в переменную» - barcode. Тогда при сканировании штрихкода возникает событие ввода и посылается запрос котрый вызывает выполнение обработчика «Обработчик Online(Обработка ввода)»
Напрмиер, на первом экране вводится штрихкод и записывается в переменную barcode. После чего экран переключается и начинает работать обработчик. В обработчике записано

.. image:: _static/txt_pic1.jpg
       :scale: 100%
       :align: center

Тут видно, что берется переменная barcode (Переменные.barcode) и запросом ищется Номенклатура с таким штрих кодом. Далее, если все нормально то заполняются переменные nom, descr , nomRef, а если нет – то выводится сообщение об ошибке. Обратите внимание на то что в переменную nomRef записывается УникальныйИдентификатор чтобы потом когда надо будет эту номенклатуру заполнять в документ, ее можно было бы найти по ссылке
А с переменными descr и nom – все просто, раз они заданы в полях надписей, они будут показаны на последующих экранах:


.. image:: _static/txt_pic2.jpg
       :scale: 100%
       :align: center


И выглядеть это будет так:

.. image:: _static/txt_pic3.jpg
       :scale: 50%
       :align: center


Обработка событий на закладке offline&REST
-------------------------------------------

.. note:: Python для обработчиков может решить буквально все задачи, а закладка Offline&REST нет. Да, не все знают этот язык, но база - работа с СУБД , работа с переменными и отправка запросов хорошо разобрана в примерах. Поэтому для 100% покрытия задач лучше использовать Python, однако некоторые простые задачи (особенно с SQL) быстро решаются с помощью закладки, к тому же возможно скорость исполнения будет чуть повыше.

Действия пользователя и прочие события в самостоятельном режиме также порождают события. Точно также каждое имя каждого события записывается в переменную *listener*. То есть основные принципы работы точно такие же. Приоритетным режимом для самостоятельных обработчиков является Python. Обработчики на Python обрабатывают не только ввод на экране но и другие события - фоновый сервис, при запуске конфигурации и другие.  С помощью Python можно сделать абсолютно все на устройстве - работать с СУБД SQL и No SQL, отправлять запросы через requests, работать с файлами и многое другое

Однако, в случае если Python использовать неудобно, можно пользоваться закладкой "Offline&REST". Команды, для обработки событий определяются на закладке Обработчик OFFline & REST. Порядок команд как он задан в табличной части подразумевает порядок обработки событий.


.. image:: _static/listener_offline.jpg
       :scale: 100%
       :align: center



Для того чтобы по событию произошел запуск команды требуется в колонке Вид обработчика указать событие:

* Обработка ввода – любое событие ввод включая штрихкод
* При открытии – при запуске экрана
* Закрытие экрана – закрытие запускаемого экрана (экран диалога) . Подробнее в Запуск экрана диалога

Для события «При запуске» уточнять тип события не нужно – оно всегда одно. А для события ввода могут быть разные события, фильтр по которым задается в колонке «Обработчик»:

**Пустое значение** – нажатие кнопки «Далее» на навигационной панели

**«перемеренная»** - нажатие кнопки или другого управляющего элемента(например списка значений) у которой стоит такая переменная. Например если в кнопке указать переменную btn_ok то при нажатии сгенерится событие с таким именем

**TableClick** – клик по таблице

**CardsClick** – клик по списку карточек

**TilesClick** – клик по плитке

**keyboard** - нажатие клавиши аппаратной клавиатуры

**BACK_BUTTON** – кнопка назад на стандартной навигационной панели

**barcode, photo, photogallery, signature, spinner** – события при обработке управляющих элементов (см. далее)

**Input1, Input2, Input3, InputDate** -  события при обработке элементов упрощенного режима разметки

События можно перечислять через запятую (в т.ч. «пустую строку»), т.е. указав ``“,barcode`` - можно задать фильтр на события «Далее» и на сканирование штрихкода.

Действия по обработки события задаются с помощью поля Вид действия и других связанных полей

Условный переход на закладке Offline&REST 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Когда строки команд добавляются в табличную часть им назначается номер. Для некоего события можно указать  Вид действия – «Проверить условие». Тогда при выполнении этой команды будет проверено условие и выполнится либо команды, перечисленные в поле «Тогда» , либо в «Иначе». Там перечисляются номера строк, через запятую, которые должны выполнится. Условие может быть люой сложности и задано в синтаксисе Java. При этом переменные задаются в обрамлении @имя_переменной@, например @a@>5 – будет проверяться выражение a>5. Или например @a>5@&&@a@<=10 будет проверяться a>5 и a<=10

.. image:: _static/bool_expression.jpg
       :scale: 100%
       :align: center



Общие элементы экранов
-----------------------

Сообщение об ошибке 
~~~~~~~~~~~~~~~~~~~~

В режиме тонкого клиента заполнение переменной СообщениеОбОшибке вызывает прерывание процесса и показ надписи в текстом ошибки внизу экрана. 

Управляющие элементы экранов (запуск действий с парящих кнопок)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Сканирование штрихкода с камеры и с аппаратного сканера
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Елси на экране требуется распознавание штрихкода, то необходимо добавить на экран элемент «Штрих-код» и указать переменную, в которую он будет записываться по факту сканирования.

Если на устройстве есть аппаратный сканер, желательно указать галочку «Аппаратный сканер» в настройках. В противном случае на экране будет присутствовать кнопка сканирования через камеру устройства. Соответственно, при сканировании через камеру при добавлении элемента Штрих-код подразумевается что будет нажиматься парящая кнопка. Также в настройках можно включить подсветку.
Также при использовании Bluetooth сканеров в режиме SSP сопряжения необходимо активировать Использовать Bluetooth и выбрать устройство и суффикс (это все обычно программируется на устройстве штрих-кодами из инструкции). Bluetooth сканеры обычно могут работать и в режиме HID но в таком случае на экране нельзя размещать другие элементы ввода – они будут перехватывать строку.
Аппаратный сканер ТСД может быть запрограммирован в режиме HID (в разрыв клавиатуры) с суффиксом CR/LF на конце. Либо он может быть запрограммирован на передачу сообщения через подписку на intent. Второй вариант лучше, потому что поля ввода не перехватывают такое сообщение и можно располагать ввод штрихкода с полями ввода на одном экране. Для использования в этом режиме надо включить галку "Использовать подписку на события сканера" и заполнить поля. Заполнение полей индивидульно для разных моделей, информацию ищите в документации либо в ПО ТСД.

Передача картинки на устройство
"""""""""""""""""""""""""""""""""""""

На экране может быть выведена картинка на том месте где находится поле описания. Рекомендую не выводить одновременно с картинкой поле описание, чтобы оставить для нее место. 
В составе этот элемент называется «Картинка»
Картинка передается через обычную переменную в виде строки Base64. Так как 1С может добавлять лишние символы, их надо убрать

``Картинка = Новый Картинка("C:\Users\Дмитрий\Pictures\хорь.jpg");
СтрокаBase64 =Base64Строка(Картинка.ПолучитьДвоичныеДанные());
//Для 1С это надо делать обязательно, иначе картинка невалидная
СтрокаBase64 = СтрЗаменить(СтрокаBase64, Символы.ВК, "");
СтрокаBase64 = СтрЗаменить(СтрокаBase64, Символы.ПС, "");
Переменные.Вставить("image",СтрокаBase64);``

Прием картинки с камеры (фотографирование)
"""""""""""""""""""""""""""""""""""""""""""

В составе экрана можно разместить элемент «Фото с камеры» , тогда на экране появится кнопка камеры. И это изображение можно передавать в переменную base64 либо выдавать ссылку на файл (с флагом mm_local). В демо базе есть простой пример по приему изображений.

Ввод картинки из галереи
""""""""""""""""""""""""""

Аналогично фотографированию, только ввод - из галереи устройства. Для этого надо расположить элемент "Фото из галереи" и задать переменную в которую будет писаться.

Горизонтальная галерея мультимедиа
""""""""""""""""""""""""""""""""""""

Элемент управления "Горизонтальная галерея мультимедиа" это и визуальный и активный элемент, который позволяет упростить работу с изображениями. Он предназначен для визуализации в виде миниатюр массива мультимедиа. Входная переменная - это JSON массив либо идентификаторов файлов (в случае флага mm_local) типа ["id1","id2"] и т.д. либо JSON массив вида [{"uid":"id1","base64":"данные картинки 1"},{"uid":"id2","base64":"данные картинки 2"}] то есть массив, содержащий непосредственно данные. Сам массив формируется когда добавляются мультимедиа с камеры или из галереи, либо удаляются. То есть для функционирования достаточно разместить элемент галереи и "Фото с камеры" или "Фото с галереи" и указать любую переменную. При работе с мультимедиа или удалении будут возникать события ввода, при которых переменную с массивом можно например сохранить. Удобнее всего это делать в режиме NoSQL (именно так устроены примеры в демо-базе). Причем даже если хранение у вас на SQL все разно сами фото можно хранить в объектах NoSQL и ссылаться на них. Для удаление нужно пометить миниатюры долгим тапом.


Галерея слайдер
""""""""""""""""""""

.. image:: _static/slider.PNG
       :scale: 35%
       :align: center


Элемент управления "Галерея слайдер" это визуальный элемент для отображения набора картинок с возможностью пролистывания. Она занимает часть экрана сверху. Нельзя разместить более одной, т.к. она не в контейнере. В качестве источника данных используется точно такая же переменная как горизонтальной переменной, т.е. массив uid-ссылок на картинки.


Режим работы с мультимедиа и файлами по ссылкам (флаг mm_local)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Можно хранить мультимедиа и галереи в виде base64-строки, но это довольно ресурсозатратный процесс. Вследствие того что кодирование и раскодирование занимает время и место, обычно при таком подходе мультимедиа сильно сжимают и по размеру и по компрессии (а видео например вообще вряд ли можно использовать с таким подходом). Альтернатива этому новый режим который задействуется переменной **mm_local** (Переменные.Вставить("mm_local","")). При таком режиме файлы хранятся на диске, а в Переменных хранятся только их идентификаторы. Т.е. при попадании новой например картинки в устройство он сохраняется на диске, взамен выдается идентификатор, далее операции производятся с идентификатором а когда нужно отправить эту картинку по синхронизации по идентификатору можно получить сам файл. Имя файла совпадает с идентификатором. Файлы хранятся во внутреннем хранилище приложения. Имя файла - сгенерированный uid. картинки можно не сжимать при таком подходе но все равно есть возможность сжимать. Для этого используются флаги **mm_compression** и **mm_size** где в качестве параметра указывается процент от 100% реального размера и 100% качества. Например hashMap.put("mm_compression","70") - это будет компрессия 70%. Использование этих 3х флагов очень простое - если флаги объявлены на экране (в "При открытии" например) то активные элементы (добавление фото, галерея и т.д.) ведут себя соответствующе - возвращают не base64 а ссылки на файлы. Сами ссылки хранятся в СУБД на устройстве в виде пар "идентификатор-путь к файлу" и могут быть получены в люой момент командой "getfiles" (hashMap.put("getfiles","")) и выданы в событии "_results" в переменную "_files". То есть всегда можно узнать абсолютный путь к файлу, получить файл и сделать с ним что угодно. Например наложить фильтры, удалить и т.д. Кроме того при синхронизации (при входящих файлах) следует также использовать специальную команду "addfile_идентификатор, путь к файлу" для того чтобы записать в массив _files идентификатор и путь.

Режим работы с файлами изображений напрямую по абсолютному пути (через ~)
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Во всех визуальных элементах (картинка на форме, картинка в карточке, в диалоге, в плитке и т.д.) возможно указание непосредственно файла на диске. Этот подход обеспечивает гораздо более высокую производительность нежели работа через base64. Особенно это заметно в больших списках где используется много изображений. Для передачи в переменную картинки следует использовать путь к файлу в файловой системе устройства с префиксом ~. Абсолютные пути к файлам могут быть доставлены в переменную _files командой getfiles, а также для обработчиков на python доступна коллекция _files через которую можно получить, записать файл по uid.

Также для отправки файлов используются фоновые команды (выполняют обмен в фоне, не блокируя ui-поток):

**post_file_УИДфайла, URL** , где УИДфайла  - уид картинки, url – ссылка на POST команду HTTP сервера на который отправи
тся картинка. Например Переменные.Вставить("post_file_"+стрИД,"http://192.168.1.143:2312/ui2/hs/simplewms/data_upload");

**post_file_array_ПерменнаяМассив, url**, где ПерменнаяМассив – переменная такая, которая используется для галереи, т.е. если напрмиер на экране расположена галерея то дополнительно ничего делать не надо можно просто написать Переменные.Вставить("post_file_array_photoArray","http://192.168.1.143:2312/ui2/hs/simplewms/data_upload")



Awesome-шрифт
""""""""""""""""

Это набор пиктограмм, с помощью которого можно сделать свои красивые кнопки, сделать иконки на карточках, экранах и т.д.Используется бесплатный набор из 1001 иконки (отбор по free + отбор по solid) https://fontawesome.com/v5.15/icons?d=gallery&p=2&s=solid&m=free 
Для того чтобы использовать, надо взять на сайте Unicode -код например f6be и присвоить переменной с префиксом # – т.е. #f6be, который потом указать в заголовке кнопки или надписи. Это можно использовать в элементах экранов, диалогов и т.д.:

 * Кнопка
 * Список кнопок
 * Горизонтальный список кнопок
 * Надпись



Ввод подписи
"""""""""""""

Добавлена возможность ввода изображения подписи с экрана (пользователь рисует свою подпись на экране) и передача этой подписи в 1С в виде картинки
Для этого необходимо поместить элемент «Подпись» на экран и задать переменную
В демо базе появился пример процесса «Пример подпись»

Голосовой ввод
"""""""""""""""

Элемент экрана «Голосовой ввод» осуществляет запуск распознавания речи от Google (на устройстве должны быть сервисы Google и интернет). Распознанная строка передается в переменную, котрую вы определите в экране.

Распознавание текста
""""""""""""""""""""""""

Для использования распознавания текста нужно поместить на экран элемент «Распознавание текста» и заполнить «Настройка распознавания» (обязательно!). Распознавание работает оффлайн. Распознаются буквы и символы толкьо в латинской раскладке и цифры. 
При распознавании строка подбирается из таблице БД на устройстве, т.е. чтобы обеспечить работу этого механизма нужно либо создать таблицу и передать туда объекты либо использовать документы (documents). Например вам нужно обеспечить поиск по товарам по артикулам на рабочем месте. Вы создаете (например через закладку конфигурации «Offline при старте») таблицу «Create table goods if not exist…”, выгружаете туда товары (примеры взаимодействия есть в демо-базе. В товарах должна быть колонка по которой сверять распознанные строки (например артикул) 
В настройке распознавания как минимум надо определить запрос к таблице, поле которое будет проверяться по результатам распознавания и настройку соответствия для заполнения переменных полями таблицы. Напрмиер в приведенном примере поиск идет по полю  таблицы field2 , и в случае успеха заполняются переменные field1,doc и field2
Также для повышения точности поиска можно повысить количество измерений и процент совпадений (минимальная средняя частота). Т.е. например если поставить измерений 10 и частоту 75 то количество измерений будет как минимум 10 (или больше) а победитель должен будет иметь процент совпадений не менее 75%

.. image:: _static/recognize.jpg
       :scale: 100%
       :align: center


Прочие элементы интерфейса
---------------------------

Синтез речи
~~~~~~~~~~~

Вывод экрана может сопровождать воспроизведение голосом текста. Текст можно задавать в переменной или непосредственно. Для этого нужно разместить на экране элемент «Голос»


.. image:: _static/speak.jpg
       :scale: 100%
       :align: center

Звуковой сигнал
~~~~~~~~~~~~~~~

Можно воспроизвести "бип" - один из 100, заложенный в Андроиде, если присвоить в переменную ``beep`` значение от 1 до 99, либо оставить пустой - тогда будет звук по умолчанию. Это работает и в онлайн и в оффлайн (через присвоение переменных). Пример в базе.
Примеры звуков есть тут:https://developer.android.com/reference/android/media/ToneGenerator#TONE_CDMA_ABBR_REORDER
В онлайн:

``Переменные.Вставить("beep","");``

В оффлайн:

.. image:: _static/beep.jpg
       :scale: 100%
       :align: center



Функции авторизации и загрузки конфигурации.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Можно организовать экран входа в систему котрый будет запускаться при запуске приложения и пункт основного меню для перелогинивания.  Для того чтобы процесс запускался при входе в приложение нужно поставить галочку «Запустить при старте»
 
Начиная с версии 4.2 появились новые функции логина - доступ к настройкам севиса(экран "Настройки") и перезапуску конфигурации. В Переменные по умолчанию записываются переменные CLIENT_CODE, WS_URL, WS_USER, WS_PASS с настройками онлай-подключения по умолчанию. Также появился элемент контейнера "Поле ввода пароля". Также появились команды RunLogin или RunSaveLogin - первая просто загружает с настройками - вторая- сохраняет настройки. Этим командам надо передать JSON типа {"code":"code","user":"user","password":"pass"} Также в JSON можно передавать  "backendURL" и "backendUser"

Для того, чтобы произошла загрузка нужной конфигурации нужно заполнить переменную «ID» кодом справочника Мобильные клиенты, нужного клиента. Это тот же код который указывается в настройках. Если с терминалом будут работать несколько человек, можно создать конфигурацию, содержащую толкьо процесс «Логин» , и другие клиенты будут подгружаться из нее. 
Также процесс с логином можно добавить во все конфигурации клиентов, в которых нужно перелогиниваться (совместное использование одного терминала)

.. image:: _static/scr_login.jpg
       :scale: 100%
       :align: center



Режим разметки экрана контейнерами 
---------------------------------------------

На экранах можно разместить произвольное количество элементов, определив их положение и оформление. Пример произвольной разметки приведен в демо базе в конфигурации «Примеры Simple UI»
Для этого используются **Контейнеры**. 

.. attention:: На экране могут быть либо контейнеры либо упрощенный режим – одновременно они работать не могут так как занимают весь экран. Если вы хотите использовать режим разметки то нужно поместить на экран элемент «Контейнер» и указать тип контейнера а в него уже поместить все остальные визуальные элементы

.. image:: _static/containers_ex.jpg
       :scale: 100%
       :align: center

Контейнеры – это группы элементов. Они могут располагаться либо горизонтально либо вертикально. Ориентация - обязательное свойство.
Также обязательно нужно  указать ширину и высоту. При этом ширину и высоту можно указать в числах, а можно в виде варианта «На весь экран» или «По размеру элементов». На весь экран означает что контейнер будет стараться занять в данном направлении всю площадь до конца экрана (по ширине или по высоте). По размеру элементов – его ширина или высота будет равна сумме размеров элементов.
При этом в контейнере может быть размещено несколько контейнеров. Если каждый из них «По размеру элементов» - то просто будут следовать друг за другом.
Если допустим каждый из них «На весь экран» и не указан «Вес» то первый контейнер займет весь экран и ничего больше не будет видно. Это нормальное поведение для Андроид. Чтобы было видно все контейнеры нужно им назначить «Вес». Допустим нам надо поделить контейнер на 2 равные части по горизонтали. Тогда у каждого нужно поставить Вес=1 и ширину «На весь контейнер». Если допустим нужно один сделать меньше другого в 2 раза то вес нужно поставить 2 у того который больше  - Вес 1 (чем больше вес тем меньше размер – это знаменатель). Сами числа тут не важны – важно соотношение.


Контейнеры с прокруткой и без прокрутки
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Контейнер по умолчанию может вместить неограниченное количество элементов т.е. имеет прокрутку содержимого. Но в случае если в нем располагаются элементы, содержащие прокрутку, например таблица или список карточек это ставит систему в неразрешимое противоречие. Таблицу можно разместить в таком контейнере но она не будет  иметь собственную прокрутку содержимого а будет пролистываться с другими элементами. Если нужно разместить эелемент с прокруткой и чтобы она работала(а сам элемент не сдвигался) нужно в экране поставить галочку **Отключить прокрутку для корневого контейнера**

Элементы контейнера
~~~~~~~~~~~~~~~~~~~~~

Контейнеры включают в себя собственные визуальные элементы. При этом невизуальные – Голос, ШтрихКод и т.д. могут быть в экране помимо корневого контейнера и использоваться. Обработка переменных происходит в обработчиках экранов. Сколько бы не было вложенных контейнеров все обработчики – в экране.

Элементы контейнера отличаются следующими свойствами:
 * их может быть неограниченное количество каждого типа
 * на каждый из них может быть задано собственное оформление
 * для кнопок есть галочка «Не обновлять экран» - происходит только отправка запроса или выполнение офлайн обработчика. Перерисовка не происходит
 * для полей ввода можно задавать предопределенные значения

**Оформление** – это справочник. По сути соответствует «стилям». Т.е. разные элементы могут использовать один и тот же элемент «Оформление».
 
.. image:: _static/style_ex.jpg
       :scale: 100%
       :align: center

Оформление включат в себя элементы «Высота», «Ширина» и «Вес» - они полностью аналогичны контейнерам. Т.е. например если поставить у кнопки ширину и высоту «На весь контейнер» то она займет весь контейнер.
Также элементы оформления
Цвет фона, цвет текста – установка цветов в HEX кодировке вместе с символом #. Посмотреть палитру можно в интернете. Андроид рекомендует использовать «матириал» цвета например с ними удобно работать вот тут : https://materialuicolors.co/ . Тут прямо можно копировать и вставлять в поля.
Размер текста – числовой размер текста
Выравнивание – Лево, Право, Центр. Выравнивание зависит от ширины и высоты. Например если надпись в контейнере котрый «По размеру элементов» по ширине, то от установки выранивания «По центру» ничего не изменится. Но если  вам надо расположить надпись по центру экрана – вам надо сделать размер контейнера «На весь контейнер» по ширине и поставить Выравнивание «По центру»
Иконка – выбор из нескольких иконок для кнопок.

Для элементов контейнера можно определить условную видимость(поле «Скрыть по условию») – переменную, в которой если будет присвоена строка “true” то этот элемент будет скрыт

.. image:: _static/hide_ex.jpg
       :scale: 100%
       :align: center
 

Виды элементов контейнера:

**Контейнер** – вложенный контейнер

**Картинка** – картинка в виде строки base 64. Работа аналогична картинкам обычного экрана

**Диаграмма** – диаграмма типа «Круговая», «Столбики» и «Линейная». Установка столбцовой и линейной диаграммы возможна по сериям. Установка значений производится путем передачи json строки и показана в «Примеры Simple UI #2»

**Индикатор** – индикатор со своей шкалой. Возможна установка минимального и максимального значения, границ красной, желтой и зеленой зон и самого значения. Установка происходит через передачу json строки. Пример формата с комментариями – в демо базе «Примеры Simple UI #2»

**Список** – выпадающий список

**Таблица** – таблица на экране. Может быть несколько таблиц расположенных как угодно  (см. также "Контейнеры без прокрутки")

**Список карточек** – прокручиваемый список карточек (см. также "Списки карточек")

**Плитки** – прокручиваемый список карточек (см. также "Плиточный экран")

**Надпись** – их может быть сколько угодно с любым оформлением

**Кнопка** – в отличии от «упрощенного режима» кнопки не располагаются в блоках а добавляются по одной и каждая вызывает событие при нажатии. 

**Поле ввода число** и **Поле ввода строка** – может быть произвольное количество полей. В отличии от упрощенного режима «Поле ввода» не имеет заголовка. Если нужен заголовок – то рядом нужно поместить «Надпись»
В «Заполнение поля» можно поместить значение или переменную для начального заполнения

**Поле ввода пароля** - поле ввода со скрытым текстом

**Поле ввода автозаполнение списка** - поле ввода с автозаполнением. В "Заполнение поля" надо передать переменную, содержащую список возможных вариантов разделенный ";". В остальном обычное поле ввода. 

**Поле ввода с событием** - обычное текстовое поле,но генерирующее событие ввода при каждом набранном символе. Можно исопльзовать для обновления таблицы на экране, зависимой от ввода например.

**Флажок** – логическое значение. В Переменные записывается “true”/”false” - именно в строковом виде.

**Документ** – можно использовать в качестве поля ввода любой тип документов. В случае использования документа нужно указать «Тип документа» , например «Клиенты». В переменные пишется json выбранного документа.
 
.. image:: _static/docs_in_screens.jpg
       :scale: 100%
       :align: center


Скрытие панелей кнопок
~~~~~~~~~~~~~~~~~~~~~~

В процессе можно указать галочку «Скрыть панель кнопок» - тогда нижняя панель будет скрыта


