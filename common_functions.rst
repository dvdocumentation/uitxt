.. SimpleUI documentation master file, created by
   sphinx-quickstart on Sat May 16 14:23:51 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Общие функции платформы
========================

Список Задачи (для он-лайн)
-----------------------------
 
.. image:: _static/common_pic7.jpg
       :scale: 60%
       :align: center


По кнопке «Задачи» теперь можно запросить учетную систему не предмет какого то списка задач, заказов и т.д. Например это могут быть «Текущие заказы к доставке для определенного пользователя»

В момент нажатии кнопки приложение делает запрос к сервису (/get_tasklist/), и он возвращает некий список. Этот список представляется пользователю как список карточек с определенным оформлением

Вместе со списком можно передать наименование операции которую надо запустить при клике на задачу, ID задачи, некий параметр который записывается в orderRef и который потом можно прочитать в обработчике.

При клике на задачу передается запрос на специальный сервис (taskcommit) с ID задачи. Это можно использовать для биллинга например.

Все это рабоатет через 2 сервиса:

 
.. image:: _static/common_pic8.jpg
       :scale: 100%
       :align: center


 
В обработчике get_tasklist приведен пример заполнения списка. Для каждой карточки можно заполнить 4 поля: заголовок, 2 реквизита (при этом установив заголовок поля) и поле примечание внизу. Также в примере показано какие еще специальные поля передаются в список и как они обрабатываются.

В демо базе пример в рабочем месте «Отгрузка» процесс «Отгрузка по заказу (из списка)» демонстрирует обработку заказа из списка.

.. tip:: Список задач также рабоатет и в самостоятельном режиме (в случае если бекенд - не 1С). Это описано в разделе REST самостоятельного режима.


Таблицы. Работа с таблицами и план-факт
-----------------------------------------

Через переменные в виде строки json можно передавать произвольные таблицы и размещать их в разных местах программы.

Произвольная таблица может быть представлена в виде:
 * **Элемента экрана**, вместе с другими элементами. Для этого нужно использовать элемент экрана «Таблица» и в переменной передать строку json в специальном формате
 * Переопределить нажатие центральной кнопки **План-факт**. Старый формат также действует, но если задана произвольная таблица то это имеет приоритет. Для этого нужно вставить переменную **central_table**.	Например : ``Переменные.Вставить("central_table",CтpoкaJSON);``
 * Вызвать отдельное окно с таблицей по какому то событию (например по нажатию кнопки) с заполненной таблицей на весь экран. Для этого нужно использовать переменную **report_table**  Например: ``Переменные.Вставить("report_table",CтpoкaJSON);``

В структуре json можно описывать :

 * столбцы таблицы – имя, заголовок, ширину колонки
 * Общие опции таблицы – размер шрифта, скрыть заголовок, отключить подсветку линий через строку
 * Непосредственно данные в ячейках
 * Раскраску отдельных ячеек произвольными цветами

Структура формата таблицы не зависит от места использования таблицы – она общая.

Пример формата:

.. code-block:: JSON

  {
  "type": "table",
  "textsize": "25",
  "hidecaption": "true",
  "hideinterline": "true",
  "columns": [
    {
      "name": "nom",
      "header": "Товар",
      "weight": "2"
    },
    {
      "name": "qty",
      "header": "Кол-во",
      "weight": "1"
    },
    {
      "name": "price",
      "header": "Цена",
      "weight": "1"
    }
  ],
  "rows": [
    {
      "name": "Процессов Intel Core 9 OEM",
      "qty": "5",
      "price": "15500.00"
    },
    {
      "name": "Процессов Intel Core 5 BOX",
      "qty": "-2",
      "price": "12500.00"
    },
    {
      "name": "Процессов Intel Core 5 (OEM)",
      "qty": "2",
      "price": "11500.00"
    }
  ],
  "colorcells": [
    {
      "row": "1",
      "column": "1",
      "color": "#d81b60"
    }
  ]
  }


Атрибут type обязательный он должен быть всегда значение «table»

**textsize** -необязательный – отвечает за размер текста

**hidecaption** – необязательный – не выводить шапку таблицы

**hideinterline** – необязательный – не выводить раскраску строк

**borders** – необязательный – выводит границы ячеек таблицы


**columns**  *обязательный* массив в котором описываются колонки. **name** – внутреннее имя, **header** -отображаетмый заголовок, **weight** – ширина колонки в виде относительного веса, **gravity** - выравнивание текста (left,right,center). Если задать все колонки в 1 то они будут равны.


**rows**  *обязательный*  массив в котором описываются строки. Каждый элемент имеет имя, совпадающее с именем столбца и значение

**colorcells** *необязательный** массив– подсветка произвольных ячеек нужным цветом. Строка и столбец задаются номерами начиная с 0. Цвет (color) – в HEX виде.

Нажатие на строку таблицы таблицы  вызывает *событие ввода* и передачи данных на сервер. Выбранная строка  - объект JSON сериализуется в переменную **selected_line**

Обработка ввода по таблице.
~~~~~~~~~~~~~~~~~~~~~~~~~~~

В версии «Pro» доступно получение события о выбранной строке таблицы. Пример помещен в конфигурацию «Примеры #2». При нажатии на таблицу в переменную «selected_line» пишется json с выбранной строкой

Для «самостоятельно режима» при клике по таблице возвращается не json. Программа ищет в выделенной строке поля **id**, **order** и **orderRef** и если они есть, записывает в переменные значения ``selected_line_id``, ``order`` и ``orderRef``

Адаптер таблицы
~~~~~~~~~~~~~~~~
В самостоятельном режиме источником данных могут служить либо запрос к SQL либо GET-запрос. Для того чтобы оформить колонки таблицы в строке запроса указывается *адаптер* - справоник в котором прописываются видимые заголовки колонок, ширина колонок и ключ(значение которое будет возвращаться по клику). В демо базе можно посмотреть пример в конфигурации "Примеры Simple UI #3"


Списки карточек
----------------


.. image:: _static/cards_list.png
       :scale: 35%
       :align: center

Списки карточек являются наиболее удобным видом представления табличных данных на мобильном устройсве. С их помощью можно организовать список выбора, таблицу или например меню.  

Карточки могут содержать 1 картинку либо, если ее нет то ее место сдвигается и остаются поля. Полей может быть сколько угодно. Они состоят из пар "Заголовок"-"Значение", но заголовка опять же может не быть. При этом можно менять размер и цвет текста, а в самих полях писать HTML-текст.

Списки карточек могут работать в он-лайн режиме, офф-лайн режиме и режиме связи с бекендом. В демо базе можно посмотреть пример в конфигурации "Примеры Simple UI#3" 

В он-лайн режиме источник данных и правла оформления задаются в виде JSON-строки на сервере.Например это может быть так (картинка отсутствует для компактности):

.. code-block:: JSON

  {
    "cards": [
    {
      "key": "key_00320055",
      "picture": "",
      "description": "какой то комментарий",
      "items": [
        {
          "key": "",
          "value": "Материнская плата GIGABYTE B450M DS3H",
          "size": "15",
          "color": "#1b31c2",
          "caption_size": "12",
          "caption_color": "#1b31c2"
        },
        {
          "key": "Цена",
          "value": 5500,
          "size": "25",
          "color": "#131e61"
        }
      ]
    },
    {
      "key": "key_00320023",
      "items": [
        {
          "key": "",
          "value": "Процессор intel i7",
          "size": "15",
          "color": "#1b31c2",
          "caption_size": "12",
          "caption_color": "#1b31c2"
        },
        {
          "key": "Цена",
          "value": 17500,
          "size": "25",
          "color": "#131e61",
          "caption_size": "12",
          "caption_color": "#1b31c2"
        },
        {
          "key": "Скидка",
          "value": 1500,
          "size": "25",
          "color": "#DC143C",
          "caption_size": "15",
          "caption_color": "#DC143C"
        }
      ]
    }
  ]
  }


В каждой карточке присутствует ключевое поле. В JSON это- "key". По нему в дальнейшем идет обработка клика по карточке.

Клик по карточке порождает событие "CardsClick" и добавляет в структуру переменных переменные "selected_card_key" и "selected_card_position" содержащие ключ и позицию карточки.


Плитки и плиточное главное меню
---------------------------------------------------


.. image:: _static/tiles_screen.png
       :scale: 35%
       :align: center

Плитки - это элемент контейнера который можно вывести на экран, либо использовать как главное меню программы (стартовый экран). Структура карточки может быть любая - она задается в контейнере точно также как в контейнере задаются элементы экрана. При этом можно использовать все те же визуальные элементы что и в экранах - надписи, картинки, диаграммы, индикатор а также кэшированные картинки. Поля ввода и другие элементы ввода использовать нельзя. 

Плитки могут визуально заменить список карточек при не очень большом количестве элементов (построение каждой плитки по шаблону занимает некоторое время и например 1000 плиток будут несколько притормаживать)

Размер (высота) плиток зависит от количества карточек в горизонтальном ряду. Есть 3 вида размера:

 *  средний размер - при количестве плиток от 2 до 3 в ряду. Высота = ширина экрана/3.14
 *  мелкий размер - количество от 4 и выше. Высота - средний размер/2
 *  большой размер - при одной плитке в ряду. Высота - минимально - такая же как у среднего размера, при необходимости - увеличивается.

Плитки задаются в JSON переменной как массив рядов, а каждый ряд - тоже массив, содержащий список плиток в ряду. 

При этом каждая плитка в обязательном порядке содержит:

 * поле **template** - имя экрана, содержащего контейнер с шаблоном - то есть экран в составе конфигурации в котором определена структура плитки. Он может быть один на все плитки, но хотя бы один шаблон должен быть обязательно. Т.е. из экрана берется корневой контейнер и его структура является структурой плитки	
 * объект **data** - объект содержащий значения переменных плитки. Т.е. в шаблоне определяется привязка переменных через @ , а в data для каждой плитки передаются данные
 * поле **color** - цвет плитки
 * поля **start_screen** и **start_process** - запуск экрана и процесса. При нажатии на плитку будет запущен процесс, указанный в плитке в поле start_process либо экран текущего процесса в поле start_screen. Вообще плиточный экран по умолчанию воспринимается как некое меню для запуска процессов – т.е. при нажатии должен стартовать процесс, а при завершении процесса возвращаться на меню. Для этого нужно указывать start_process в плитке. Но также можно использовать его для как шаг процесса как например используется таблица или список плиток – для запуска экрана с закрытием текущего шага. Для этого используется start_screen
 * плитка может содержать поле **key** которое передается в обработчик при нажатии

Также в общем объекте определено поле **background_color** - в нем задается фон под плитками.



.. code-block:: JSON

  {
    "tiles": [
      [
        {
          "template": "Узкая плитка 1",
          "data": {
            "room": "котельная",
            "temp": "23°C",
            "rate": "11°C...28°C",
            "port": "N1"
        },
        "color": "#78002e",
        "start_screen": "",
        "start_process": "Процесс 1"
      },
      {
        "template": "Узкая плитка 1",
        "data": {
          "room": "водоподготовка",
          "temp": "24°C",
          "rate": "11°C...29°C",
          "port": "N1"
          },
          "color": "#78002e",
          "start_screen": "",
          "start_process": "Процесс 2"
        }
      ],
      [
        {
          "template": "Широкая плитка 1",
          "data": {
            "room": "Отопление",
            "default_temp": "23°C",
            "temp": "20 °C",
            "state_pic": "^flame"
          },
          "color": "#4b830d",
          "start_screen": "",
          "start_process": "Редактирование процесс"
        }
      ],
      [
        {
          "template": "Маленькая плитка",
          "data": {
            "pic": "home"
          },
          "color": "#26a69a",
          "start_screen": "",
          "start_process": "Процесс 1"
        },
        {
          "template": "Маленькая плитка",
          "data": {
            "pic": "mail"
          },
          "color": "#00acc1",
          "start_screen": "",
          "start_process": "Процесс 2"
        },
        {
          "template": "Маленькая плитка",
          "data": {
            "pic": "notification"
          },
          "color": "#320b86",
          "start_screen": "",
          "start_process": "Процесс 2"
        },
        {
          "template": "Маленькая плитка",
          "data": {
            "pic": "notification"
          },
          "color": "#320b86",
          "start_screen": "",
          "start_process": "Процесс 2"
        }
      ]
    ],
    "background_color": "#f5f5f5"
  }


При нажатии на плитку происходит запуск либо экрана либо процесса (в зависимости от того, что определено в качестве действия) в который передаются переменные, состав объекта data а также если определен ключ то передается **selected_tile_key**. Событие ввода называется **TilesClick**


Переопределение стартового меню
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. image:: _static/tiles_menu.png
       :scale: 35%
       :align: center


Меню можно сделать красивым и информативным используя плитки. Дело не только в эстетике - на плитки можно выводить оперативную информацию сразу, не погружаясь в процесс. Например количество текущих заказов или задач. Для этого плитка должна обновляться в фоновом процессе (например По расписанию Python), но чтобы происходила отрисовка нужно еще добавлять команду **UpdateMenu**. Таким образом меняя переменные в JSON будут менять данные на плитках в фоне, независимо от состояния приложения (даже в режиме сна).

Чтобы переключить режим меню нужно в конфигурации выбрать "Вид стартового экрана" - "Плитки", а также заполнить "Плиточный контейнер для запуска" (откуда будут браться шаблоны) и задать какую то глобальную переменную , например "_tiles" через которую из обработчиков будет передаваться состав плиток. Как минимум нужно определить эту переменную в обработчике "При запуске Python" конфигурации.


Корзина
---------


.. image:: _static/cart.png
       :scale: 35%
       :align: center

 


Корзина - это организация списка в виде карточек (не в виде таблицы) с обработкой изменения количества и удаления, как в приложениях интернет-магазинов. Корзину можно использовать для заказов, Scan&Go розницы и много чего еще. Ввиду ограничений ОС, в контейнерах корзина не доступна - она может занимать только весь экран. Поэтому ее следует разместить на экране без контейнера.

Корзина состоит из карточек и итогов внизу. В карточках доступно изменение количества дискретно и удаление. Эти действия обрабатываются на устройстве - пересчитываются итоги, меняется список + возникает событие которые можно обработать он-лайн. 

Карточки могут содержать 1 картинку либо, если ее нет то ее место сдвигается и остаются поля. Полей может быть сколько угодно. Они состоят из пар "Заголовок"-"Значение", но заголовка опять же может не быть. При этом можно менять размер и цвет текста, а в самих полях писать HTML-текст.

Принцип работы с корзиной такой: структура корзины - это карточки и итоги. Карточки - это JSON - массив. Сначала например можно описать пустую корзину, это будет пустой массив, а также описанный формат итогов. В итогах задается:

 * заголовки итогов
 * по каким переменным каточек их считать (у карточки есть видимые поля, а есть невидимые - они нужны например для дальнейшей обработки состава корзины и для подстчета итогов) а также формат текста и округление

.. code-block:: JSON

  {
  "cart": [],
  "totals": [
    {
      "caption": "Итого:",
      "var": "sum"
    },
    {
      "caption": "Экономия:",
      "var": "discount"
    }
  ]
  }


За формат текста отвечает поле **format** (напрмер "0.0" - один знак после запятой), за цвет и размер **size**, **color** (для значений) и  **caption_size**, **caption_color** (для заголовков). В демо базе есть пример Scan&Go - лучше иметь его перед глазами чтобы ознакомиться

Для добавления в корзину карточек (это можно прописать например при сканировании) в массив "cart" добавляется новый JSON объект. Это карточка. Она может содержать следующие поля:

 * **qty** - колчиество. Должно быть какое то начальное количество. Например 1
 * **picture** - base64-строка с картинкой. Лучше не слишком большие.
 * **массив items** - массив видимых текстовых данных карточки. Поля key, value - заголовок и текст (причем оба значения необязательны), цвета и размеры **size**, **color** (для значений) и  **caption_size**, **caption_color** (для заголовков). Доступен html-текст
 * **массив values** - массив невидимых данных карточки. Тут могут быть числовые поля для того, чтобы рассчитать итоги (они упоминаются в totals) и просто какие то поля для дальнейшей обработки, напрмиер ссылка на номенклатуру. Структура JSON объекта не предопределённая - просто любые поля и значения.


Картинки из кеша
--------------------

Для повышения быстродействия интерфейса, особенно для повторяющихся элементов, например в карточках, рекомендуется передавать картинки не через base64 а указывать их в конфигурации на странице "Медиаресурсы". Так, картинки передаются вместе с конфигурацией и загружаются на устройство в виде файлов (в папке приложения). 

Дальнейшая работа с ними происходит в формате **^имя ресурса** , где имя ресурса вы определяете на странице "Медиаресурсы". Такое обращение доступно везде где есть объект "Картинка" - экраны, карточки и т.д. Также для плиток можно указывать не явную ссылку а ссылку на переменную, а явная ссылка указывается в объекте **data** плитки. Проще всего посмотреть пример в демо базе "Примеры работы с плитками и главным меню" , переменную плиток главного меню, где у маленьких плиток шаблон один и тот же, а картинки - разные.

Также использование таких картинок более удобно для структурирования проекта.



Чтение клавиатуры
--------------------

На экране (начиная с версии 3.50.10) можно задать флаг "Подключить чтение клавиатуры". Это не требует настройки в конфигурации. Просто, когда происходит нажатие одного из сочетаний клавиш генерируется событие listener= **keyboard** и в переменную keyboard возвращается считанная клавиша. Список клавиш такой:

 * сочетания с Ctrl
 * сочетания с Alt
 * сочетания с Shift
 * F1-F12




Запуск процессов из процессов и другие управляющие команды
-----------------------------------------------------------

Можно немедленно запустить процесс из другого процесса, если в присвоить переменной ``StartProcessHashMap`` строку, содержащую имя вызываемого процесса. Это вызовет запуск нового окна с другим процессом– туда скопируются переменные из вызывающего окна и выполнятся все процессы. После того как работа с новым процессом будет закончена – в старом процессе работа продолжится с текущего шага. С помощью этого приема удобно организовывать цикл в цикле. Пример в демо базе: «Цикл в цикле»

Также есть другая аналогичная функция - StartProcess. Вызов: присваивание переменной  ``StartProcess`` строку, содержащую имя вызываемого процесса. Это будет просто переключение процесса без возврата на вызывающий процесс.


GPS
-----

В настройках есть галочка «Отправлять координаты» если ее включить то в люом процессе который запущен будут добавляться специальные переменные относящиеся к службе геопозиционирования. 

.. attention:: Необходимо в настройках дать приложению разрешение на определение местоположения. Также необходимо убедиться, что в устройстве включено определение местоположения.

Устройство запрашивает данные каждые 5 секунд и отправка происходит каждый раз когда отправляются переменные. Сразу в момент запуск апроцесса данных может не быть, нужно чуть-чуть подождать.

Данные запрашиваются и поступают с 2х провайдеров – gps и network (сети или wi-fi) – в обработчике можно фильтровать по факту.

Специальные переменные, в котрые устройство передает данные: 

 * **Latitude** – широта
 * **Longitude** – долгота
 * **gps_city** – город, если есть в адресе
 * **gps_postal_code** – индекс
 * **gps_addres_string** – полная неразобранная информация , которую можно разобрать по тегам
 * **gps_provider** – источник данных
 * **gps_accuracy** -  точность

Уведомления и тосты
--------------------

Команды уведомлений работают из любого контекста вызова, не только на экранах, но и из фона и команд по расписанию.

.. image:: _static/toast.jpg
       :scale: 35%
       :align: center

**toast** - всплывающее внизу экрана уведомление. В качестве параметра просто текст сообщения. Работает в любом контексте. Например Переменные.Вставить("toast","Привет мир!");


.. image:: _static/basic_notification.jpg
       :scale: 35%
       :align: center

**basic_notification** - простое уведомление на экран блокировки c темой и текстом. Работает отовсюду, в том числе из фона. Совместно с сервисом по расписанию можно использовать как замену push. Можно передавать несколько сразу, поэтому в качестве параметра передается JSON- массив. Каждое уведомление должно иметь свой номер. По номеру можно обновлять уже выведенные обновления. Например можно вывести уведомление «Началась обработка» с номером 1, а потом послать еще одно уведомление «Обработка завершена» с номером 1 и ОС обновит на экране существующее уведомление елси его еще не смахнул пользователь, если его нет – выведет новое. Пример запуска уведомления Переменные.Вставить("basic_notification","[{""number"":1,""title"":""Информация"",""message"":""Привет мир!""}]"); 

Тут в JSON зарезервированные слова «number», «title» и «message» - номер, тема и сам текст сообщения

.. image:: _static/reply_notification.jpg
       :scale: 35%
       :align: center

**reply_notification** - частный случай обычного уведомления с такими же параметрами запуска, только в уведомлении можно нажать кнопку «Ответить» , ввести текст ответа и отправить его. При ответе сработает специальный обработчик конфигурации на котором можно прописать свою логику. В обработчике доступна переменная reply с текстом, который ввел пользователь. Таким образом можно например отправить текст http-запросом. Этот вид уведомлений поддерживается Android начиная с Oreo. 




Экран диалога в двух вариантах
--------------------------------

Модальный экран
~~~~~~~~~~~~~~~~~

Можно запустить модальный экран(обычный экран со всем функционалом обычных экранов) для ввода значений с кнопками «ОК» и «Отмена» и перехватывать событие этого экрана. В случае нажатия на ОК будет вызвано событие ввода и переменные этого экрана могут быть обработаны. 

Состав экрана вы определяете сами – это обычный экран

Вызов экрана через обработчик – ``Переменные.Вставить(«StartScreen», «Имя экрана»)``. Вызываемый экран должен быть в составе процесса.

Получение события через обработчик: переменная event установлена в ``“OnResult”``

.. image:: _static/common_pic10.jpg
       :scale: 80%
       :align: center

 
Запуск экрана Offline: вид действия для запуска «Запустить экран», параметр – **точное** название экрана диалога который есть в составе процесса

Событие ввода : Вид обработчика – «Закрытие экрана», в Обработчике указываете название экрана диалога. Пример есть в демо.



Диалог
~~~~~~~~~~~~

.. image:: _static/dialog_new.jpg
       :scale: 35%
       :align: center


Также доступен модальный диалог в визуальном стиле стандартных диалогов и с возможностью переопределения кнопок и заголовка. Для этого испольуется команда **ShowDialog** На нем можно разместить свои элементы ввода. Для этого нужно в параметрах команды указать экран в котором есть контейнер, и элементы этого корневого контейнера будут использованы в наполнении диалога.

Также можно определить загловок и название кнопок ОК/Отмена, передав переменную ShowDialogStyle. 

Например так: ``Переменные.Вставить("ShowDialog","Диалог ввода по-новому"); Переменные.Вставить("ShowDialogStyle","{  ""title"": ""Авторизируйтесь"",   ""yes"": ""Войти"",   ""no"": ""Отмена"" }");``

При этом диалог возращает события onResultPositive и onResultNegative в зависимости от того, что выбрал пользователь.








Логин и запуск конфигурации
------------------------------------

Можно организовать экран входа в систему котрый будет запускаться при запуске приложения и пункт основного меню для перелогинивания.  Для того чтобы процесс запускался при входе в приложение нужно поставить галочку **«Запустить при старте»**

 
.. image:: _static/common_pic9.jpg
       :scale: 100%
       :align: center

Начиная с версии 4.2 появились новые функции логина - доступ к настройкам севиса(экран "Настройки") и перезапуску конфигурации. В Переменные по умолчанию записываются переменные CLIENT_CODE, WS_URL, WS_USER, WS_PASS с настройками онлай-подключения по умолчанию. Также появился элемент контейнера "Поле ввода пароля". Также появились команды RunLogin или RunSaveLogin - первая просто загружает с настройками - вторая- сохраняет настройки. Этим командам надо передать JSON типа {"code":"code","user":"user","password":"pass"} Также в JSON можно передавать  "backendURL" и "backendUser"

Для того, чтобы произошла загрузка нужной конфигурации нужно заполнить переменную ``ID``  кодом справочника Мобильные клиенты, нужного клиента. Это тот же код который указывается в настройках. Если с терминалом будут работать несколько человек, можно создать конфигурацию, содержащую толкьо процесс «Логин» , и другие клиенты будут подгружаться из нее. 
Также процесс с логином можно добавить во все конфигурации клиентов, в которых нужно перелогиниваться (совместное использование одного терминала)


Печать на мобильном устройстве
-------------------------------

На мобильном устройстве доступна печать PDF-документа сформированного на стороне сервера. Например это может быть печатаная форма, сохраненная в 1С. В демо базе есть пример создания печатной формы и экрана для печати – см. команду print_pdf HTTP сервиса SimpleWMS.

Принцип работы следующий:

 * Обработчик события (кнопки или иного события) на устройстве инициирует запрос в сервис /print_pdf. Передавая при этом строку параметров ктоорые нужны для печати формы. Разработчик сам формирует эту строку и сам предусматривает параметры
 * Обработчик команды находит нужный документ или объект, формирует печатную форму и сохраняет в PDF отправляет в ответе
 * На стороне устройства читается ответ, извлекается PDF и отправляется менеджеру печати.

Для онлайн-режима:

Команда печати передается через переменную PrintService. Например так. В качестве значения нужно передать строку параметров запроса который пойдет на сервер

``Переменные.Вставить("PrintService","operation=print&barcode="+Переменные.barcode);``

Далее в модуле команды print_pdf параметры извлекаются и на основании этой информации формируется ответ с печатной формой
В operation можно передать либо **print** либо **view** – и это же должно пойти в ответе. На основании этого параметра откроется либо сразу менеджер печати либо программа просмотра PDF

.. hint:: если print не работает - попробуйте view. Это зависит от устройства и софта.


**Для документов**:

В отличии от экранов строка параметров формируется автоматически и в ней идет команда doc_print и предопределенный параметр uid – в котором содержится УИД Экземпляра документа. Также идет параметр template – с названием печатной формы.

Для определения списка печатных форм документа нужно добавить необходимо добавить их в табличную часть «Печать». Вид печати – «Печать через сервис». Остальное можно не заполнять.




Веб-сервис на клиенте. Возможности
-----------------------------------

Передача задания напрямую на устройство
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

На клиент может быть отправлено задание (пример есть в форме документа «Заказ покупателя»). Это не просто отправка и не просто отправка напрмую, а еще и прямое взаимодействие - так как пользователь может быть занят или отказаться от задания и это все в режиме реального времени будет видно в учетной системе в процессе.

 
.. image:: _static/common_pic2.jpg
       :scale: 100%
       :align: center


Для этого достаточно указать адрес клиента (это адрес веб-сервера на мобильном устройстве, которых храниться в справочнике «Мобильные клиенты»),ТаблицаЗаказа (заполненную как указано ранее), сообщение, которое будет отображено в диалоге, имя процесса.

``Функция ОтправитьЗаданиеНаОтборПоЗаказуМобильныйКлиент(АдресТерминала,Команда,ТаблицаДанных,Сообщение,Процесс,Заказ )   Экспорт``

Также при передаче такого сообщения передаются переменные **order** и **orderRef** содержащие ссылку на заказ (параметр Заказ) и представление заказа
При приеме сообщения веб-сервер клиента проверяет, не занят ли клиент выполнением какого то другого процесса и если занят отправляет ответ **busy, если нет то ответ будет **recieved**. Если же произошла ошибка при доставке то ответ будет другой. Также состаояние загрузки мобильного клиента можно прочитать в регистре сведений scСтатусыИсполненияПроцессов


При доставке сообщения на главном экране будет показан диалог и прозвучит звук приема сообщения (даже если экран выключен, так как веб-сервер рабоатет как сервис)

 
.. image:: _static/common_pic3.jpg
       :scale: 50%
       :align: center


Если пользователь нажимает «Да», то запускается процесс котрый был указан в методе. Важно: в конфигурации пользователя должен присутствовать этот процесс.


Передача голосового сообщения на устройство 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Можно отправить текст на конкретное устройство, и оно будет произнесено с помощью синтеза речи даже если программа свернута или выключен экран блокировки. 

Для этого нужно использовать команду ``Voice`` с параметром ``text``. Например так:

``Справочники.scМобильныеКлиенты.ОтправитьSQLЗапросМобильныйКлиент(URLМобильногоУстройства,"Voice","text","&text=Ваша фраза на языке по умолчанию”)``


Команды SQL и Передача конфигурации
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Данные команды описаны в разделее Самостоятельный режим


Odata
-------

Если в серверной части параллельно с веб-сервисом опубликован интерфейс Odata то можно вместо заполнения источников данных запросами через обработчики просто указать запрос к OData в конструкторе.
Для этого необходимо в настройках программы указать адрес сервера Odata

.. image:: _static/common_pic4.jpg
       :scale: 50%
       :align: center


После чего можно использовать OData запросы для таблицы или списка как показано на рисунках. Обратите внимание что для списка нужен толкьо одно поле – берется первое поле. Поэтому его лучше определить оператором select
Для таблицы выводятся все поля, но их тоже лучше определять select чтобы не было лишних столбцов

.. image:: _static/common_pic5.jpg
       :scale: 100%
       :align: center

.. image:: _static/common_pic6.jpg
       :scale: 100%
       :align: center


Запуск/Переключение экранов с сервера напямую и таймер событий экрана/обработчик ожидания (только для Pro-версии)
------------------------------------------------------------------------------------------------------------------

Возможно с сервера передавать на конкретное устройство команду переключения экрана (после которой устройство шлет запрос send_input и отрисовывает экран по новой). Это может понадобится например для организации информационных табло на телевизорах с Андроид. Т.е. для любого открытого процесса выполнится переключение экрана.

Это можно сделать например строкой ``Справочники.scМобильныеКлиенты.ОтправитьSQLЗапросМобильныйКлиент(URLМобильногоУстройства,"Run","txt","&text=blob");``

Пример есть в демо базе в обработке «Примеры взаимодействия с сервером»

Также можно подписать экран на выполнение периодической команды переключения экрана. Это может понадобится для той же цели – периодического показа например какого то информационного экрана. Таймер задается в настройках приложения. Признак того что экран будет выполниться по расписанию – вот эта галочка. В демо базе можно посмотреть пример с Индикаторами. Будет работать толкьо если у вас – Pro-версия.
 
.. image:: _static/common_pic1.jpg
       :scale: 80%
       :align: center


Замеры производительности
--------------------------

Для того чтобы изменить время выполнения экрана (допустим операций, перечисленный в ПриОткрытии) нужно запустить его с помощью установки переменной ``RunTestScreen`` а значение – имя экрана. После загрузки в переменную ``TestResult`` будет помещено время выполнения в миллисекундах.

Отправка статусов
------------------

Как уже было описано выше, при запуске процесса и при его окончании, отправляется запрос set_status. Данные пишутся в регистр «scСтатусыИсполненияПроцессов». По этому регистру можно мониторить состояние загруженности кладовщиков . Эти данные можно использовать для диспетчеризации отправки заданий кладовщикам (отправлять на незанятые клиенты). Ну и так как туда пишется время начала и окончания процесса, то легко посчитать длительность выполнения операций, что обычно используется в отчетах по эффективности работы. 


