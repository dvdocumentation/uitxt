.. SimpleUI documentation master file, created by
   sphinx-quickstart on Sat May 16 14:23:51 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Справочник по всем командам-переменным
===============================================

Все команды в Simple UI работают через **Переменные** - для того, чтобы запустить команду нужно установить в **ключ** саму команду, **значение** переменной при этом является параметром команды. Например ``Переменные.Вставить("ShowScreen","Экран 2");`` - переключит текущий экран на «Экран 2» . После выполнения команда сама удаляется из стека переменных.


Экраны, диалоги и процессы
---------------------------

**ShowScreen** – команда переключения экрана. В переменную передается точное название запускаемого экрана. Экраны запускаются в рамках одного процесса, то есть он должен присутствовать в процессе в видимом или невидимом виде. В случае отсутствия система выдаст ошибку. Переменные при этом сохраняются между экранами.


**ShowDialog** – команда вызова модального диалога в стандартном виде (визуально отличается от StartScreen). Диалог может содержать поля ввода и другие отображаемые элементы контейнера. В качестве параметра передается название экрана в процессе, содержащего контейнер (наличие контейнера - обязательно). Таким образом система заполняет диалог тем содержимым, которое указано в контейнере в том расположении, которое задано в контейнере. При нажатии ОК возникает событие onResult и заполняются переменные полей ввода.


**StartScreen** – запуск обычного экрана в режиме модального диалога, но как обычный экран. Отличается от команды ShowDialog внешним видом и тем, что это полноценный экран Т.е. это экран который появляется поверх экрана с кнопками «Ок/Отмена» внизу и ожидает успешного или неуспешного завершения диалога. В случае успешного завершения возникает событие ввода


**StartProcess** или **RunNewProcess**- запуск нового процесса в новом окне с закрытием текущего, т.е. без возможности возврата на текущий процесс. Локальные переменные сохраняются. В качестве параметра передается имя запускаемого процесса.


**StartProcessHashMap** - запуск нового процесса в новом окне с возможностью возврата на текущий процесс (т.е. текущий процесс остается на том же месте). Локальные переменные сохраняются. В качестве параметра передается имя запускаемого процесса.


**RunTestScreen**  - запуск экрана в режиме замера времени. Используется для замера времени алгоритмов и отрисовки экрана. Измеряемые алгоритмы нужно помещать в «ПриОткрытии» тогда после открытия будет произведено вычисление времени с момента запуска команды до момент отрисовки. После загрузки в переменную TestResult будет помещено время выполнения в миллисекундах.


**hold** - удержание экрана. Без параметра. Экран не будет перерисован при отправке обработчика события.


**break** - немедленное закрытие экрана без подтверждения


**FinishProcess** - немедленное закрытие процесса без подтверждения


**ExitProcess** - закрытие процесса с диалогом подтвержения


**report_table** - открытие экрана с произвольной таблицей просто для отображения.  В качетсве параметра передается JSON с таблицей 


**сentral_tabl** - установка произвольной таблицы на экран «План-факт». Когда пользователь запустит «План/Факт» из нижней панели он увидит эту таблицу.  В качестве параметра передается JSON с таблицей 


Уведомления, звуки и речь
--------------------------

Команды уведомлений работают из любого контекста вызова, не только на экранах, но и из фона и команд по расписанию.

**toast** - всплывающее внизу экрана уведомление. В качестве параметра просто текст сообщения. Работает везде. Например ``Переменные.Вставить("toast","Привет мир!");``


**basic_notification** - простое уведомление на экран блокировки c темой и текстом. Работает отовсюду, в том числе из фона. Совместно с сервисом по расписанию можно использовать как замену push. Можно передавать несколько сразу, поэтому в качестве параметра передается JSON- массив. Каждое уведомление должно иметь свой номер. По номеру можно обновлять уже выведенные обновления. Например можно вывести уведомление «Началась обработка» с номером 1, а потом послать еще одно уведомление «Обработка завершена» с номером 1 и ОС обновит на экране существующее уведомление елси его еще не смахнул пользователь, если его нет – выведет новое. Пример запуска уведомления: ``Переменные.Вставить("basic_notification","[{""number"":1,""title"":""Информация"",""message"":""Привет мир!""}]");`` 

Тут в JSON зарезервированные слова «number», «title» и «message» - номер, тема и сам текст сообщения


**reply_notification** - частный случай обычного уведомления с такими же параметрами запуска, только в уведомлении можно нажать кнопку «Ответить» , ввести текст ответа и отправить его. При ответе сработает специальный обработчик конфигурации на котором можно прописать свою логику. В обработчике доступна переменная reply с текстом, который ввел пользователь. Таким образом можно например отправить текст на веб сервис. 


**beep** - воспроизведение звукового сигнала нужного тона. Без параметра воспроизводится звук по умолчанию, также можно передать свой вариант звука из доступных в системе. Подробнее тут: https://uitxt.readthedocs.io/ru/latest/screens.html?highlight=beep#id18

Совместно с beep: **beep_volume** - громкость, **beep_duration** - продолжительность в мсек

**vibrate** - вибрация. Можно указывать продолжительность в качестве параметра

**speak** - синтез речи из текста, отовсюду в приложении даже из фона и с выключенным экраном. В качестве параметра передается просто текстовая строка которую надо произнести и система ее воспроизводит.

**listen** - голосовой ввод (распознавание речи) отовсюду, но с оговоркой что в настоящий момент событие ввода будет сгенерировано только если команда запущена из процесса, так как «события ввода» происходят в контексте процессов. В случае контекста приложения (например из обработчика «При открытии») распознанная переменная будет вставлена в обычные или глобальные переменные, но события не будет. 


Динамическое изменение элементов экрана и конфигурации в целом
--------------------------------------------------------------------

**getJSONScreen** записывает в переменную **JSONScreen** исходную структуру текущего экрана.
**setJSONScreen** применяет измененную структуру эжкрана

**getJSONConfiguration**  - считывает в переменную _configuration текущую конфигурацию
**setJSONConfiguration** - применяет измененную конфигурацию немедленно.



Команды Python
---------------

**RunPy** - запускает синхронное выполнение скрипта Python в UI-потоке приложения. В качестве параметра передается скрипт в виде Base64-строки


**RunPyThread** - запускает асинхронное фоновое выполнение скрипта Python. В качестве параметра передается скрипт в виде Base64-строки


Логин и загрузка конфигурации
------------------------------

**RunLogin** и **RunSaveLogin** - команды, немедленно перезапускающие клиент с новыми настройками доступа, указанными в параметрах. При этом RunSaveLogin еще и записывает настройки. Подробнее тут: https://uitxt.readthedocs.io/ru/latest/screens.html?highlight=RunSaveLogin#id19


**ID** - команда, которая загружает рабочее место с переданным в качестве параметра ID. В принципе это частный случай команды **RunLogin**
 так как в ней также можно задавать ID клиента.


Запись и чтение констант
-------------------------

Константы – это значения, записанные в файловую систему, т.е. хранящиеся между запусками приложения. Подробнее написано тут и разобрано в демо https://uitxt.readthedocs.io/ru/latest/screens.html?highlight=WriteVarStringValue#id2

**WriteVarString** + **WriteVarValue**- записывает константы

**ReadVarString** - чтение константы


Прочие команды
----------------

**PrintService** команда запуска PDF-документа на печать встроенной службой печати. Подробно описана тут https://uitxt.readthedocs.io/ru/latest/common_functions.html?highlight=PrintService#id13




