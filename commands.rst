.. SimpleUI documentation master file, created by
   sphinx-quickstart on Sat May 16 14:23:51 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Справочник по всем командам-переменным
===============================================

Все команды в Simple UI работают через **Переменные** - для того, чтобы запустить команду нужно установить в **ключ** саму команду, **значение** переменной при этом является параметром команды. Например ``Переменные.Вставить("ShowScreen","Экран 2");`` - переключит текущий экран на «Экран 2» . После выполнения команда сама удаляется из стека переменных.


Экраны, диалоги и процессы
---------------------------

**ShowScreen** – команда переключения экрана. В переменную передается точное название запускаемого экрана. Экраны запускаются в рамках одного процесса, то есть он должен присутствовать в процессе в видимом или невидимом виде. В случае отсутствия система выдаст ошибку. Переменные при этом сохраняются между экранами.

**BackScreen** – Возврат на предыдущий экран, если вызов был с ShowScreen.

**ShowDialog** – команда вызова модального диалога в стандартном виде (визуально отличается от StartScreen). Диалог может содержать поля ввода и другие отображаемые элементы контейнера.При нажатии ОК возникает событие onResult и заполняются переменные полей ввода.

**ShowDialogLayout**, <JSON-структура котнейнера> - определяет содержимое окна диалога. Используется совместно с командой ShowDialog

**ShowDialogStyle**, {"title":<заголовок>,"yes":<кнопка Да>,"no":<кнопка Нет>} - переопределяет заголовок и кнопки диалога

**StartScreen** – запуск обычного экрана в режиме модального диалога, но как обычный экран. Отличается от команды ShowDialog внешним видом и тем, что это полноценный экран Т.е. это экран который появляется поверх экрана с кнопками «Ок/Отмена» внизу и ожидает успешного или неуспешного завершения диалога. В случае 
успешного завершения возникает событие ввода

**StartProcess** или **RunNewProcess**- запуск нового процесса в новом окне с закрытием текущего, т.е. без возможности возврата на текущий процесс. Локальные переменные сохраняются. В качестве параметра передается имя запускаемого процесса.

**StartProcessHashMap** - запуск нового процесса в новом окне с возможностью возврата на текущий процесс (т.е. текущий процесс остается на том же месте). Локальные переменные сохраняются. В качестве параметра передается имя запускаемого процесса.

**ShowProcessResult** , <имя процесса|имя экрана> запускает процесс и выбранный экран, ожидая что в нем произойдет вызов **FinishProcessResult**. Стек переменных при этом на запускаемый и запускающий процесс – общий. Для того чтобы обработать именно нужное событие а не просто событие (по умолчанию listener=<имя вызываемого процесса>) совместно с этой командой можно установить имя события, которое будет сгенерировано после вызова FinishProcessResult , командой **SetResultListener** , <имя события>

**FinishProcessResult**, без параметров – завершает процесс с генерацией события в вызывающем процессе

**SetResultListener** , <имя события> - устанавливает имя события при завершении процесса

**RunTestScreen**  - запуск экрана в режиме замера времени. Используется для замера времени алгоритмов и отрисовки экрана. Измеряемые алгоритмы нужно помещать в «ПриОткрытии» тогда после открытия будет произведено вычисление времени с момента запуска команды до момент отрисовки. После загрузки в переменную TestResult будет помещено время выполнения в миллисекундах.

**hold** - удержание экрана. Без параметра. Экран не будет перерисован при отправке обработчика события.

**break** - немедленное закрытие экрана без подтверждения

**FinishProcess** - немедленное закрытие процесса без подтверждения

**ExitProcess** - закрытие процесса с диалогом подтвержения

**report_table** - открытие экрана с произвольной таблицей просто для отображения.  В качетсве параметра передается JSON с таблицей 

**сentral_table** - установка произвольной таблицы на экран «План-факт». Когда пользователь запустит «План/Факт» из нижней панели он увидит эту таблицу.  В качестве параметра передается JSON с таблицей 

Режим записи переменных при возврате из обработчика StackAddMode
----------------------------------------------------------------------

Обработчик начиная свое выполнение забирает содержимое стека переменных, а после выполнения возвращает назад перезаписью стека. При параллельной работе в нескольких потоках и одновременно при длительном выполнении обработчиков, может случиться коллизия – длительный обработчик вернет состояние переменных и перезапишет то, что за это время успело поменяться в других потоках, например пользователем. 
Для избежания этой коллизии следует определить переменную **_StackAddMode** до начала обработчиков, тогда возвращаемый стек переменных будет в режиме объединения а не замещения


Стандартные переменные процессов
------------------------------------

**parent_screen** – экран, из которого запущен текущий экран (если он был запущен ShowScreen)

**current_process_name** – имя текущего процесса

**current_screen_name** – имя текущего экрана

Запуска таймеров из кода
------------------------------

Таймеры (повторяющиеся в фоне задания) можно определить в конфигурации и также  в новом релизе запустить/остановить из кода.

**StartTimers** , пустой параметр – инициализирует объект таймеров

**StartTimer**, <{"handler":<массив обработчиков>,"period":<периодичность, мс>}> - добавляет новый таймер и запускает его

**StopTimers**, пустой параметр – останавливает объект таймеров и удаляет все ранее добавленные таймеры (командой StartTimer)



Команды управления обработчиками
-------------------------------------

**RunEvent**, параметр: строка в формате обработчиков - запуск массива люых обработчиков. Т.е. это это генерация произвольного события из кода.

**BreakHandlers** - прерывание выполнения массива обработчиков. Может быть вызвана в каком то обработчике массива (например, проверка ввода) чтобы прервать весь остальной массив

**BreakHandlersIfError**, без параметра – прерывает дальнейшее выполнение массива обработчиков если в текущем обработчике ошибка


Уведомления, звуки и речь
--------------------------

Команды уведомлений работают из любого контекста вызова, не только на экранах, но и из фона и команд по расписанию.

**toast** - всплывающее внизу экрана уведомление. В качестве параметра просто текст сообщения. Работает везде. Например ``Переменные.Вставить("toast","Привет мир!");``

**basic_notification** - простое уведомление на экран блокировки c темой и текстом. Работает отовсюду, в том числе из фона. Совместно с сервисом по расписанию можно использовать как замену push. Можно передавать несколько сразу, поэтому в качестве параметра передается JSON- массив. Каждое уведомление должно иметь свой номер. По номеру можно обновлять уже выведенные обновления. Например можно вывести уведомление «Началась обработка» с номером 1, а потом послать еще одно уведомление «Обработка завершена» с номером 1 и ОС обновит на экране существующее уведомление елси его еще не смахнул пользователь, если его нет – выведет новое. Пример запуска уведомления: ``Переменные.Вставить("basic_notification","[{""number"":1,""title"":""Информация"",""message"":""Привет мир!""}]");`` 

Тут в JSON зарезервированные слова «number», «title» и «message» - номер, тема и сам текст сообщения


**reply_notification** - частный случай обычного уведомления с такими же параметрами запуска, только в уведомлении можно нажать кнопку «Ответить» , ввести текст ответа и отправить его. При ответе сработает специальный обработчик конфигурации на котором можно прописать свою логику. В обработчике доступна переменная reply с текстом, который ввел пользователь. Таким образом можно например отправить текст на веб сервис. 

**beep** - воспроизведение звукового сигнала нужного тона. Без параметра воспроизводится звук по умолчанию, также можно передать свой вариант звука из доступных в системе. Подробнее тут: https://uitxt.readthedocs.io/ru/latest/screens.html?highlight=beep#id18

Совместно с beep: **beep_volume** - громкость, **beep_duration** - продолжительность в мсек

**vibrate** - вибрация. Можно указывать продолжительность в качестве параметра

**speak** - синтез речи из текста, отовсюду в приложении даже из фона и с выключенным экраном. В качестве параметра передается просто текстовая строка которую надо произнести и система ее воспроизводит.

**listen** - голосовой ввод (распознавание речи) отовсюду, но с оговоркой что в настоящий момент событие ввода будет сгенерировано только если команда запущена из процесса, так как «события ввода» происходят в контексте процессов. В случае контекста приложения (например из обработчика «При открытии») распознанная переменная будет вставлена в обычные или глобальные переменные, но события не будет. 


Динамическое изменение элементов экрана и конфигурации в целом
--------------------------------------------------------------------

**getJSONScreen** записывает в переменную **JSONScreen** исходную структуру текущего экрана.

**setJSONScreen** применяет измененную структуру эжкрана

**getJSONConfiguration**  - считывает в переменную _configuration текущую конфигурацию

**setJSONConfiguration** - применяет измененную конфигурацию немедленно.


Прочие команды Экранов
------------------------

**RunCV** - запуск режима AciveCV из экрана. После завержения ActiveCV в таком варианте запуска, возникает событие ввода с listener=ActiveCV

**StartMediaGallery** - запуск выбора файла из галереи мультимедиа, котрый можно инициировать из кода (т.е. определить на свою кнопку например)

**StartCaptureCamera** - запуск камеры

**SetTitle** , параметра: заголовок экрана - переопределение заголовка экрана

**PrintPreview** ,параметр:html-строка - запуск окна с предпросмотром html. Для например, печатных форм, которые из этого окна можно отправить на принтер

**PrintService** команда запуска PDF-документа на печать встроенной службой печати. Подробно описана тут https://uitxt.readthedocs.io/ru/latest/common_functions.html?highlight=PrintService#id13

**ViewPDF**, **PrintPDF** , параметр: путь к PDF-файлу - предпросмотр и печать локального PDF-файла


Прочие функции, запускаемые из фонового сервиса или общих обработчиков
--------------------------------------------------------------------------

**ShowProcessScreen**, параметр: {"process":<process>,"screen":<screen>} - запуск любого экрана любого процесса из любого состояния приложения (в случае если основной контекст приложения запущен)
**SpeechRecognitionListener**, параметр: задержка - запуск распознавания речи с паузой для ожидания ответа
**SendIntent** - отправка из фона некоего события ввода, на котрое подписаны экраны и ActiveCV (там возникает событие ввода)
**BackgroundCommand** - команда, которой можно передать управление в фоновый Сервис событий и запустить там какой то обработчик

Функции, связанные с SQL и NoSQL
-----------------------------------

Описаны в разделе Хранение

Функции, связанные с векторной графикой
------------------------------------------

Описаны в разделе Векторная графика


Команды Python
---------------

**RunPy** - запускает синхронное выполнение скрипта Python в UI-потоке приложения. В качестве параметра передается скрипт в виде Base64-строки. Устаревшее, рекомендуется использовать запуск массива обработчиков.

**RunPyThreadDef** - запускает асинхронное фоновое выполнение скрипта Python. В качестве параметра передается имя фунции

**RunPyThreadProgressDef** - аналогично команде **RunPyThread** , но запускает прогресс-бар, который блокирует UI-поток. В качестве аргумента - имя функции.


Логин, загрузка конфигурации, настроек
-----------------------------------------

**SetSettingsJSON**, параметр: JSON строка с настройками в формате настроек SimpleUI. Загрузка любых настроек программы, при необходимости конфигурации

**RunLogin** и **RunSaveLogin** - команды, немедленно перезапускающие клиент с новыми настройками доступа, указанными в параметрах. При этом RunSaveLogin еще и записывает настройки. Подробнее тут: https://uitxt.readthedocs.io/ru/latest/screens.html?highlight=RunSaveLogin#id19

**ID** - команда, которая загружает рабочее место с переданным в качестве параметра ID. В принципе это частный случай команды **RunLogin**  так как в ней также можно задавать ID клиента.


Логирование и дампы состояния переменных
-----------------------------------------------------

**start_sys_log** – запускает запись лога.Начинает накапливаться журнал ошибок приложения а также записи состяния переменных "До" и "После" выполнения обработчиков. Пример работы в "Примеры 6" в демо-базе. Лог хранится на устройстве оффлайн.

**stop_sys_log** – останавливает запись лога. Записанный лог при этом остается в памяти.

**send_sys_log, url** – отправляет на нужный URL данные записанного журнала. Данные приходят в виде JSON-массива котоый можно расшифровать и получить журнал ошибок и работы приложения. 

**clear_sys_log** – очищает лог


Бекап и восстановление СУБД
-------------------------------

**backup_sql** - выгружает асинхронно файл "SimpleWMS" в папку, выбранную в настойках в качестве "папки для оффлайн обмена"

**restore_sql** - загружает файл "SimpleWMS" в СУБД


Отправка файлов-картинок на http-сервис
-----------------------------------------

**post_file_УИДфайла, url** , где УИДфайла  - уид картинки, url – ссылка на POST команду HTTP-сервера на который отпарвится картинка. Например Переменные.Вставить("post_file_"+стрИД,"http://192.168.1.143:2312/ui2/hs/simplewms/data_upload");

**post_file_array_ПерменнаяМассив, url** , где ПерменнаяМассив – переменная такая, которая используется для галереи, т.е. если напрмиер на экране расположена галерея то дополнительно ничего делать не надо можно просто написать Переменные.Вста


Прочие общие функции, не зависящие от контекста
------------------------------------------------

**setLocale** - запись настройки Locale для многоязычной поддержки

**app_shutdown** - выключение приложения если возможно. Ну или по крайней мере - перезагрузка

**UpdateMenu** - команда которая обновляет меню. Меню может быть перерисовано по разным причинам, например информация на плитках или изменился состав процессов в конфигурации из кода. Данная команда инициирует обновление без перезапуска.

**RefreshMenu** - команда которая обновляет меню, но в отличии от UpdateMenu не перечитывает конфигурацию, не обновляет конфигурацию и не выполняет события при запуске

**UpdateConfigurations** - обновляет конфигурации (аналог нажатия соответствующей кнопки через главное меню)

**InstallConfiguration** - закрепляет конфигурацию в репозитории (аналог кнопки pin в тулбаре)


Работа с WorkManager
---------------------------

**StartWork** параметр {"work":<массив обработчиков>,"tag":<тэг задачи>,"retry":true,"conditions":<список условий запуска задачи>} - запуск однократного воркера с неким тегом, флаг retry в true указывает на то что задача в случае неудачи будет бесконечно перезапускаться пока не будет выполнена или отменена. conditions-список условий выполнения через ";". Доступны следующие условия: CONNECTED (наличие связи); BATTERY_NOT_LOW (заряд батареи больше 15%); CHARGING (устройство на зарядке); IDLE (устройство не используется)

**StartPeriodicWork**,параметр {"work":<массив обработчиков>,"period":<период>,"tag":<тэг задачи>,"conditions":<список условий>} - запуск периодической задачи с периодом period в минутах. Минимальный период - 15 минут

**StopWork**, параметр <тег задачи> Останавливает задачу с определенным тегом. Это может быть периодическая задача или однократная в состоянии RETRY

**StartDownloadWorkRequest**,параметр {"request":<описание запроса>,"tag":<тег задачи>,"title":<(необаятельный), заголовок в шторке уведомлений>,"body":<(необазательный), текст в уведомлении>} - запуск воркера на скачивание файла в бинарном режиме
Описание запроса: {"url":<URL или псевдоним точки доступа>,"method":<метод HTTP>,"file":<имя файла, куда будет производиться запись>,"postExecute":<при необходимости, массив обработчиков по окончанию выполнения> }. Если используется альяс, предварительно записанный в HTTPAddAlias, то как правило в нем есть все необходимое для подключение – авторизация, заголовки. Если не используется то можно определить сразу в описании запроса.

**StartUploadWorkRequest**,{"request":<описание запроса>,"tag":<тег задачи>,"title":<необаятельный, заголовок в шторке уведомлений>,"body":<необазательный, текст в уведомлении>}
Описание запроса: {"url":<URL или псевдоним точки доступа>,"method":<метод HTTP>,"file":<имя файла, куда будет производиться запись>,"postExecute":<при необходимости, массив обработчиков по окончанию выполнения> }


Работа с WebSocket
---------------------------

Команды описаны в разделе "Веб-сокеты"

Нативные команды модуля android 
-------------------------------------

Команды описаны в разделе "python"




